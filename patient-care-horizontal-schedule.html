<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patient Care Schedule - Horizontal Layout</title>
    <!--
    Patient Care Schedule Application
    Version: 3.1.1
    Date: July 21, 2025
    Features: OBS Ward Observation, Enhanced Popup with Staff Allocation Tracking,
             Patient Care Ratio Enforcement, Night Shift Cleaning Duties with Reassignment,
             Break Management, Interactive Cleaning Duty Assignment, jQuery Popup Fix
    -->
    <style>
        /* Core styling for light and dark modes */
        :root {
            --background-color: #f9f9f9; /* Light background */
            --text-color: #333333; /* Dark text color */
            --container-bg-color: #ffffff; /* White container background */
            --button-bg-color: #0077ff; /* Bright blue button color */
            --button-hover-bg-color: #0056cc; /* Darker blue for hover */
            --table-header-bg-color: #f3f4f6; /* Light gray for table headers */
            --table-header-text-color: #333333; /* Dark text for table headers */
            --table-cell-bg-color: #ffffff; /* White table cell background */
            --table-cell-text-color: #333333; /* Dark text color for table cells */
            --break-bg-color: #ffefc1; /* Soft yellow for breaks */
            --lunch-bg-color: #c1f0c1; /* Soft green for lunch */
            --unassigned-bg-color: #ffc1c1; /* Soft red for unassigned */
            --primary-font: 'Poppins', sans-serif; /* Modern font */
        }

        /* Dark mode overrides */
        body.dark-mode {
            --background-color: #1f2937; /* Dark background */
            --text-color: #f9fafb; /* Light text color */
            --container-bg-color: #374151; /* Dark gray container background */
            --button-bg-color: #2563eb; /* Blue button color */
            --button-hover-bg-color: #1d4ed8; /* Darker blue for hover */
            --table-header-bg-color: #4b5563; /* Darker gray for table headers */
            --table-header-text-color: #f9fafb; /* Light text for table headers */
            --table-cell-bg-color: #4b5563; /* Dark gray table cell background */
            --table-cell-text-color: #f9fafb; /* Light text color for table cells */
            --break-bg-color: #fbbf24; /* Yellow for breaks */
            --lunch-bg-color: #22c55e; /* Green for lunch */
            --unassigned-bg-color: #ef4444; /* Red for unassigned */
        }

        /* General body styling */
        body {
            font-family: var(--primary-font);
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.8;
            transition: background-color 0.5s ease, color 0.5s ease;
        }
        h1, h2 {
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-top: 20px;
        }
        h2 {
            font-size: 1.8rem;
        }
        .container {
            width: 100%; /* Ensure it takes full width */
            max-width: 1200px; /* Limit the maximum width */
            min-width: 800px; /* Ensure a minimum width for smaller content */
            margin: 0 auto;
            padding: 30px;
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            overflow-x: auto; /* Allow horizontal scrolling for overflowing content */
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease;
        }
        .setup-section {
            background-color: var(--container-bg-color); /* Use dark mode container background */
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e0e4e8;
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease; /* Smooth transition */
        }
        .setup-section h2 {
            margin-bottom: 10px;
        }
        .staff-inputs, .patient-inputs, .security-staff-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;

        }
        input, select {
            padding: 8px;
            border: 1px solid #dfe4ea;
            border-radius: 5px;
            width: 150px; /* Shortened width */
            font-size: 14px;
            background-color: #ffffff;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        input:focus, select:focus, button:focus {
            outline: 3px solid #4a69bd;
            box-shadow: 0 0 5px rgba(74, 105, 189, 0.5);
        }
        button {
            background-color: var(--button-bg-color);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: var(--button-hover-bg-color);
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background-color: var(--table-cell-bg-color);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 15px;
            text-align: center;
            font-size: 14px;
            background-color: var(--table-cell-bg-color);
            color: var(--table-cell-text-color);
            transition: background-color 0.5s ease, color 0.5s ease;
        }
        th {
            background-color: var(--table-header-bg-color);
            color: var(--table-header-text-color);
            font-weight: 600;
        }
        tr:nth-child(even) td {
            background-color: #f9fafb;
            color: var(--table-cell-text-color); /* Explicitly set text color */
        }
        tr:nth-child(odd) td {
            background-color: var(--table-cell-bg-color);
            color: var(--table-cell-text-color); /* Explicitly set text color */
        }
        .row-header {
            background-color: var(--table-header-bg-color);
            color: var(--table-header-text-color);
            font-weight: bold;
            text-align: left;
        }
        .staff-break {
            background-color: var(--break-bg-color);
            color: #000000; /* Ensure black text for contrast with yellow background */
            font-weight: bold;
        }
        .staff-lunch {
            background-color: var(--lunch-bg-color);
            color: #000000; /* Ensure black text for contrast with green background */
            font-weight: bold;
        }
        .schedule-container {
            overflow-x: auto;
            margin-top: 20px;
        }
        .stats {
            margin-top: 20px;
            background-color: var(--container-bg-color); /* Use dark mode container background */
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e0e4e8;
            color: var(--text-color); /* Ensure text color adapts to dark mode */
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease; /* Smooth transition */
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 50%;
        }
        .legend-break {
            background-color: var(--break-bg-color);
        }
        .legend-lunch {
            background-color: var(--lunch-bg-color);
        }
        .legend-unassigned {
            background-color: var(--unassigned-bg-color);
        }
        .legend-security {
            background-color: #ffccbc;
        }
        .legend-night-break {
            background-color: #673ab7;
        }
        .staff-cleaning-duty {
            background-color: #9c27b0; /* Purple color for cleaning duties */
            color: #ffffff; /* White text for contrast */
            font-weight: bold;
        }

        .legend-cleaning-duty {
            background-color: #9c27b0;
        }

        /* Ensure text color is visible for cells with white background in dark mode */
        body.dark-mode td {
            color: var(--text-color); /* Use the light text color defined for dark mode */
        }

        body.dark-mode tr:nth-child(even) td {
            background-color: #374151; /* Dark gray for even rows in dark mode */
            color: var(--table-cell-text-color); /* Ensure text color is visible */
        }

        body.dark-mode tr:nth-child(odd) td {
            background-color: var(--table-cell-bg-color); /* Dark gray for odd rows in dark mode */
            color: var(--table-cell-text-color); /* Ensure text color is visible */
        }

        /* Explicitly set text color for cells with white background */
        body.dark-mode td[style*="background-color: #ffffff"] {
            color: #333333; /* Dark text color for white background */
        }

        .staff-count {
            padding: 5px; /* Reduce padding */
            border: 1px solid #dfe4ea;
            border-radius: 5px;
            width: 80px; /* Adjust width to save space */
            font-size: 12px; /* Reduce font size */
            background-color: #ffffff;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .staff-count:focus {
            outline: none;
            border-color: #4a69bd;
            box-shadow: 0 0 5px rgba(74, 105, 189, 0.5);
        }

        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #f44336;
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 1000;
        }

        /* Explicitly set text color for cells when in dark mode */
        body.dark-mode .staff-break {
            background-color: var(--break-bg-color); /* Your dark mode yellow */
            color: #000000; /* Keep black text which contrasts with yellow */
        }

        body.dark-mode .staff-lunch {
            background-color: var(--lunch-bg-color); /* Your dark mode green */
            color: #000000; /* Keep black text which contrasts with green */
        }

        /* Other cells with custom colors in dark mode may need adjustments */
        body.dark-mode td.row-header {
            color: var(--table-header-text-color);
        }

        .rotation-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .rotation-table th, .rotation-table td {
            border: 1px solid #e5e7eb;
            padding: 15px;
            text-align: center;
            font-size: 14px;
        }

        .rotation-table th {
            background-color: var(--table-header-bg-color);
            color: var(--table-header-text-color);
            font-weight: 600;
        }

        /* Staff selection popup */
        #staffPopup {
            display: none;
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -30%);
            background-color: var(--container-bg-color);
            color: var(--text-color);
            border: 2px solid var(--button-bg-color);
            border-radius: 8px;
            z-index: 2000;
            padding: 20px;
            min-width: 300px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
        }

        #staffPopup h3 {
            margin-top: 0;
        }

        #staffList {
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }

        /* Break adjustment controls */
        .break-adjustment-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .break-adjustment-controls .action-button {
            padding: 8px 16px;
            font-size: 14px;
            margin: 0;
        }

        .action-button {
            background-color: var(--button-bg-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-right: 10px;
        }

        .action-button:hover {
            background-color: var(--button-hover-bg-color);
        }

        #editableBreakTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        #editableBreakTable th,
        #editableBreakTable td {
            border: 1px solid #e5e7eb;
            padding: 12px;
            text-align: center;
            font-size: 14px;
        }

        #editableBreakTable th {
            background-color: var(--table-header-bg-color);
            color: var(--table-header-text-color);
            font-weight: 600;
        }

        #editableBreakTable td {
            background-color: var(--table-cell-bg-color);
            color: var(--table-cell-text-color);
        }

        .break-time-select {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: var(--container-bg-color);
            color: var(--text-color);
            font-size: 13px;
            width: 100%;
            max-width: 120px;
        }

        .staff-break-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .staff-break-actions button {
            padding: 4px 8px;
            font-size: 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            color: white;
        }

        .reset-staff-btn {
            background-color: #f59e0b;
        }

        .reset-staff-btn:hover {
            background-color: #d97706;
        }

        /* Dark mode adjustments for break controls */
        body.dark-mode .break-time-select {
            background-color: var(--table-cell-bg-color);
            border-color: #6b7280;
        }

        body.dark-mode #editableBreakTable th {
            border-color: #6b7280;
        }

        body.dark-mode #editableBreakTable td {
            border-color: #6b7280;
        }

        /* Add any additional styles for the popup here */
    </style>
</head>
<body>
    <div class="container">
        <!-- Title dynamically updates based on the current shift -->
        <h1 id="siteTitle">Day Shift Allocation</h1>

        <!-- Buttons for toggling shift and dark mode -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <button id="toggleShiftBtn" style="padding: 10px 20px; font-size: 14px;">Switch to Night Shift</button>
            <button id="toggleModeBtn" title="Toggle Dark/Light Mode"></button>
        </div>

        <!-- Replace the Security Staff and Nurse in Charge sections with this flex container -->
        <div class="setup-section" style="margin-bottom: 20px;">
            <div style="display: flex; gap: 40px; align-items: flex-start;">
                <!-- Security Staff Section -->
                <div>
                    <h2>Security Staff <span style="color: red;">*</span></h2>
                    <div class="security-staff-inputs" id="securityStaffInputs">
                        <div class="security-container">
                            <input type="text" placeholder="Enter Security Staff Name" class="security-name" required>
                        </div>
                    </div>
                </div>

                <!-- Combined Nurses Section -->
                <div>
                    <h2>Nursing Staff</h2>
                    <div style="margin-bottom: 15px;">
                        <label for="nurseInChargeInput"><strong>Nurse in Charge 1:</strong></label>
                        <input type="text" id="nurseInChargeInput" placeholder="Enter First Nurse in Charge" style="width: 250px; margin-bottom: 15px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label for="nurseInCharge2Input"><strong>Nurse in Charge 2:</strong></label>
                        <input type="text" id="nurseInCharge2Input" placeholder="Enter Second Nurse in Charge" style="width: 250px; margin-bottom: 15px;">
                    </div>
                </div>
            </div>
        </div>

        <!-- Add this new section for Health Care Workers only -->
<div class="setup-section" style="margin-bottom: 20px;">
    <h2>Health Care Workers</h2>
    <div class="staff-inputs" id="staffInputs"></div>
    <button id="addStaffBtn">Add Health Care Worker</button>
    <button id="removeStaffBtn">Remove Health Care Worker</button>
</div>

        <!-- Section for managing health care workers and patients -->
        <div class="setup-section">
            <h2>Patient Names</h2>
            <div class="patient-inputs" id="patientInputs"></div>
            <button id="addPatientBtn">Add Patient</button>
            <button id="removePatientBtn">Remove Patient</button>

            <!-- Buttons for generating and resetting the schedule -->
            <button id="generateBtn">Generate Schedule</button>
            <button id="resetBtn">Reset</button>
            <!-- Debugging Button -->
            <!-- This button is for debugging purposes only. Remove this button and its functionality before final deployment. -->
            <button id="debugFillBtn" style="background-color: #ff5722; color: white; margin-top: 10px;">Debug: Fill Random Names</button>
        </div>

        <!-- Legend for schedule colors -->
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color legend-break"></div>
                <div>30-min Break</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-lunch"></div>
                <div>1-hour 2nd Break</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-unassigned"></div>
                <div>Emergency Assignment</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-security"></div>
                <div>Security Duty</div>
            </div>
        </div>

        <!-- Schedule tables -->
        <div class="schedule-container">
            <h2>Patient Care Schedule <span style="font-size: 0.6em; color: #666; font-weight: normal;">(v3.1.1)</span></h2>
            <table id="scheduleTable">
                <thead id="scheduleHeader"></thead>
                <tbody id="scheduleBody"></tbody>
            </table>
        </div>

        <div class="schedule-container">
            <h2>Staff Schedule</h2>
            <table id="staffTable">
                <thead id="staffHeader"></thead>
                <tbody id="staffBody"></tbody>
            </table>
        </div>

        <div class="schedule-container">
            <h2>Staff Break Hours</h2>
            <table id="breakHoursTable">
                <thead>
                    <tr>
                        <th>Staff</th>
                        <th>30-min Break</th>
                        <th>1-hour 2nd Break</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <!-- Manual Break Time Adjustment Section -->
        <div class="schedule-container" id="manualBreakAdjustment" style="display: none;">
            <h2>Manual Break Time Adjustment</h2>
            <p>Adjust break times for staff members. Changes will update all tables and statistics automatically.</p>
            <div class="break-adjustment-controls">
                <button id="toggleBreakAdjustment" class="action-button">Enable Break Time Editing</button>
                <button id="resetAllBreaks" class="action-button" style="display: none;">Reset All Breaks</button>
                <button id="saveBreakChanges" class="action-button" style="display: none;">Apply Changes</button>
            </div>
            <div id="breakAdjustmentTable" style="display: none;">
                <table id="editableBreakTable">
                    <thead>
                        <tr>
                            <th>Staff</th>
                            <th id="firstBreakHeader">30-min Break</th>
                            <th id="secondBreakHeader">1-hour 2nd Break</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- Statistics section -->
        <div class="stats" id="stats"></div>

        <!-- Staff-Patient Rotation section -->
        <div class="stats" id="rotationStats"></div>

        <button id="resetRotationBtn" class="action-button">Reset Rotation History</button>
    </div>

    <div id="debugPanel" style="display: none; position: fixed; bottom: 0; right: 0; width: 400px; height: 300px; background-color: rgba(0,0,0,0.8); color: white; padding: 10px; overflow: auto; z-index: 1000; font-family: monospace; font-size: 12px;">
    <h3 style="margin-top: 0; border-bottom: 1px solid white;">Debug Console</h3>
    <button id="clearDebugBtn" style="position: absolute; top: 10px; right: 10px; background-color: #f44336; color: white; border: none; border-radius: 4px; padding: 5px;">Clear</button>
    <div id="debugOutput"></div>
</div>

<button id="toggleDebugBtn" style="position: fixed; bottom: 10px; right: 10px; background-color: #333; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer; z-index: 999;">üêû</button>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        // Add this function near the top of your script section with other utility functions
        function getInitials(fullName) {
            if (!fullName) return '';

            // Split the name by spaces
            const nameParts = fullName.trim().split(' ');

            // If it's a single name, return first 2 letters
            if (nameParts.length === 1) {
                return nameParts[0].substring(0, 2).toUpperCase();
            }

            // Otherwise return first letter of first name + first letter of last name
            const firstInitial = nameParts[0][0] || '';
            const lastInitial = nameParts[nameParts.length - 1][0] || '';

            return (firstInitial + lastInitial).toUpperCase();
        }

        // In the updateLegend function, update the break hours table header
        function updateLegend() {
            // Update legend based on shift
            const legendDiv = document.querySelector('.legend');
            if (isDayShift) {
                legendDiv.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color legend-break"></div>
                        <div>30-min Break</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-lunch"></div>
                        <div>1-hour 2nd Break</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-unassigned"></div>
                        <div>Emergency Assignment</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-security"></div>
                        <div>Security Duty</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4CAF50;"></div>
                        <div>OBS</div>
                    </div>
                `;
            } else {
                legendDiv.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color legend-night-break"></div>
                        <div>2-hour Break</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-cleaning-duty"></div>
                        <div>Cleaning Duty</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-unassigned"></div>
                        <div>Emergency Assignment</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-security"></div>
                        <div>Security Duty</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4CAF50;"></div>
                        <div>OBS</div>
                    </div>
                `;
            }

            // Update break hours table header
            const breakHoursTableHead = document.querySelector('#breakHoursTable thead');
            if (isDayShift) {
                breakHoursTableHead.innerHTML = `
                <tr>
                    <th>Staff</th>
                    <th>30-min Break</th>
                    <th>1-hour 2nd Break</th>
                </tr>`;
            } else {
                breakHoursTableHead.innerHTML = `
                <tr>
                    <th>Staff</th>
                    <th>2-hour Break Block</th>
                    <th>Duration</th>
                </tr>`;
            }
        }

        // Global variables
        let schedule = {};
        let isDayShift = true;
        let timeSlots = [];
        let securityStaff = [];
        let nurseInCharge1 = '';
        let nurseInCharge2 = '';
        let staffPatientHistory = {};

        // Cleaning duties for night shift (global scope)
        let cleaningDuties = [
            "DINING ROOM", "OFFICE ROOM", "TAKE OUT BINS", "LAUNDRY ROOM", "PHONE ROOM",
            "LOUNGE", "KITCHEN", "QUIET ROOM", "CORRIDOR", "TOILETS"
        ];

        // Time slot definitions
        const dayShiftSlots = ["08:00-09:00", "09:00-10:00", "10:00-11:00", "11:00-12:00", "12:00-13:00", "13:00-14:00", "14:00-15:00", "15:00-16:00", "16:00-17:00", "17:00-18:00", "18:00-19:00", "19:00-20:00"];
        const nightShiftSlots = ["20:00-21:00", "21:00-22:00", "22:00-23:00", "23:00-00:00", "00:00-01:00", "01:00-02:00", "02:00-03:00", "03:00-04:00", "04:00-05:00", "05:00-06:00", "06:00-07:00", "07:00-08:00"];

        // Initialize time slots
        timeSlots = [...dayShiftSlots];

        // Helper functions
        function getInputValues(selector) {
            return Array.from(document.querySelectorAll(selector)).map(input => input.value.trim());
        }

        function getElement(id) {
            return document.getElementById(id);
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            }
        }

        // Enhanced error display function with different message types
function showMessage(message, type = 'info') {
    const messageDiv = document.getElementById('message') || createMessageDiv();

    // Set message content
    messageDiv.textContent = message;

    // Set styling based on message type
    messageDiv.className = `message message-${type}`;
    messageDiv.style.display = 'block';

    // Auto-hide after 5 seconds for info messages, longer for warnings/errors
    const hideDelay = type === 'error' ? 10000 : (type === 'warning' ? 7000 : 5000);
    setTimeout(() => {
        messageDiv.style.display = 'none';
    }, hideDelay);
}

function createMessageDiv() {
    const messageDiv = document.createElement('div');
    messageDiv.id = 'message';
    messageDiv.style.cssText = `
        display: none;
        padding: 15px;
        margin: 15px 0;
        border-radius: 5px;
        font-weight: bold;
        text-align: center;
        position: fixed;
        top: 20px;
        right: 20px;
        max-width: 400px;
        z-index: 1000;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    `;

    // Add styles for different message types
    const style = document.createElement('style');
    style.textContent = `
        .message-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .message-warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        .message-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .message-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
    `;
    document.head.appendChild(style);
    document.body.appendChild(messageDiv);

    return messageDiv;
}

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        // Simplified saveToLocalStorage function that only stores essential data
        function saveToLocalStorage() {
            try {
                // Get all current input values
                const staffInputs = Array.from(document.querySelectorAll('.staff-name')).map(input => input.value.trim());
                const patientInputs = Array.from(document.querySelectorAll('.patient-container')).map(container => {
                    return {
                        name: container.querySelector('.patient-name').value.trim(),
                        staffCount: parseInt(container.querySelector('.staff-count').value)
                    };
                });

                const securityStaffValues = Array.from(document.querySelectorAll('.security-name')).map(input => input.value.trim());
                const nurseInCharge1 = document.getElementById('nurseInChargeInput')?.value.trim() || '';
                const nurseInCharge2 = document.getElementById('nurseInCharge2Input')?.value.trim() || '';

                // Save only essential data: names, preferences, and input fields
                const data = {
                    staff: staffInputs,
                    nurseInCharge1,
                    nurseInCharge2,
                    patients: patientInputs,
                    securityStaff: securityStaffValues,
                    isDayShift, // Day/night shift toggle
                    isDarkMode: document.body.classList.contains('dark-mode') // Dark/light mode toggle
                };

                localStorage.setItem('patientCareData', JSON.stringify(data));
                return true;
            } catch (error) {
                console.error("Error saving to localStorage:", error);
                showError("Failed to save your changes. Your browser storage might be full or restricted.");
                return false;
            }
        }

        // Simplified loadFromLocalStorage function to match
        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('patientCareData');
                if (!savedData) {
                    console.warn("No data found in localStorage.");
                    // Add default data
                    addStaffInput();
                    addPatientInput();
                    return false;
                }

                const parsedData = JSON.parse(savedData);

                // Load shift type
                isDayShift = parsedData.isDayShift !== undefined ? parsedData.isDayShift : true;
                timeSlots = isDayShift ? [...dayShiftSlots] : [...nightShiftSlots];

                // Update UI for shift type
                document.getElementById('siteTitle').textContent = isDayShift ? "Day Shift Allocation" : "Night Shift Allocation";
                document.getElementById('toggleShiftBtn').textContent = isDayShift ? "Switch to Night Shift" : "Switch to Day Shift";

                // Load dark mode setting
                if (parsedData.isDarkMode) {
                    document.body.classList.add('dark-mode');
                    document.getElementById('toggleModeBtn').textContent = '‚òÄÔ∏è';
                } else {
                    document.body.classList.remove('dark-mode');
                    document.getElementById('toggleModeBtn').textContent = 'üåô';
                }

                // Load nurse in charge values
                if (document.getElementById('nurseInChargeInput')) {
                    document.getElementById('nurseInChargeInput').value = parsedData.nurseInCharge1 || '';
                }
                if (document.getElementById('nurseInCharge2Input')) {
                    document.getElementById('nurseInCharge2Input').value = parsedData.nurseInCharge2 || '';
                }

                // Load staff, patients, and security staff
                loadStaffFromData(parsedData.staff || []);
                loadPatientsFromData(parsedData.patients || []);
                loadSecurityStaffFromData(parsedData.securityStaff || []);

                // Initialize empty schedule when loading (instead of loading saved schedule)
                schedule = {};

                // Set up legend based on shift type
                updateLegend();

                console.log("Data loaded successfully from localStorage");
                return true;
            } catch (error) {
                console.error("Error loading from localStorage:", error);
                showError("Failed to load your saved data. Using default settings instead.");
                return false;
            }
        }

        // Helper functions for loadFromLocalStorage
        function loadStaffFromData(staffData) {
            const staffInputs = document.getElementById('staffInputs');
            staffInputs.innerHTML = '';

            staffData.forEach(name => {
                const staffContainer = document.createElement('div');
                staffContainer.className = 'staff-container';

                const newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.value = name;
                newInput.className = 'staff-name';
                newInput.addEventListener('input', debounce(saveToLocalStorage, 300));

                staffContainer.appendChild(newInput);
                staffInputs.appendChild(staffContainer);
            });

            // Add at least one staff input if none were loaded
            if (staffData.length === 0) {
                addStaffInput();
            }
        }

        function loadPatientsFromData(patientsData) {
            const patientInputs = document.getElementById('patientInputs');
            patientInputs.innerHTML = '';

            patientsData.forEach(({ name, staffCount }) => {
                const patientContainer = document.createElement('div');
                patientContainer.className = 'patient-container';

                const inputWrapper = document.createElement('div');
                inputWrapper.style.display = 'flex';
                inputWrapper.style.alignItems = 'center';
                inputWrapper.style.gap = '10px';

                const newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.value = name;
                newInput.className = 'patient-name';
                newInput.addEventListener('input', debounce(saveToLocalStorage, 300));

                const staffCountSelect = document.createElement('select');
                staffCountSelect.className = 'staff-count';
                staffCountSelect.addEventListener('change', debounce(saveToLocalStorage, 300));

                const option1 = document.createElement('option');
                option1.value = 1;
                option1.textContent = '1:1';
                const option2 = document.createElement('option');
                option2.value = 2;
                option2.textContent = '2:1';
                const option3 = document.createElement('option');
                option3.value = 3;
                option3.textContent = '3:1';

                staffCountSelect.appendChild(option1);
                staffCountSelect.appendChild(option2);
                staffCountSelect.appendChild(option3);
                staffCountSelect.value = staffCount || 1;

                inputWrapper.appendChild(newInput);
                inputWrapper.appendChild(staffCountSelect);
                patientContainer.appendChild(inputWrapper);
                patientInputs.appendChild(patientContainer);
            });

            // Add at least one patient input if none were loaded
            if (patientsData.length === 0) {
                addPatientInput();
            }
        }

        function loadSecurityStaffFromData(securityStaffData) {
            const securityStaffInputs = document.getElementById('securityStaffInputs');
            securityStaffInputs.innerHTML = '';

            // Reset the global array
            securityStaff = [];

            securityStaffData.forEach(name => {
                if (!securityStaff.includes(name)) {
                    securityStaff.push(name);
                }

                const securityContainer = document.createElement('div');
                securityContainer.className = 'security-container';

                const newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.value = name;
                newInput.className = 'security-name';
                newInput.addEventListener('input', debounce(saveToLocalStorage, 300));

                securityContainer.appendChild(newInput);
                securityStaffInputs.appendChild(securityContainer);
            });
        }

        function clearAllData() {
            // Clear all input containers
            document.getElementById('staffInputs').innerHTML = '';
            document.getElementById('patientInputs').innerHTML = '';

            // Clear security staff input value (but keep the static input)
            const securityInput = document.querySelector('.security-name');
            if (securityInput) {
                securityInput.value = '';
            }

            document.getElementById('nurseInChargeInput').value = '';
            document.getElementById('nurseInCharge2Input').value = '';

            // Clear all display areas
            document.getElementById('scheduleHeader').innerHTML = '';
            document.getElementById('scheduleBody').innerHTML = '';
            document.getElementById('staffHeader').innerHTML = '';
            document.getElementById('staffBody').innerHTML = '';
            document.getElementById('breakHoursTable').querySelector('tbody').innerHTML = '';
            document.getElementById('stats').innerHTML = '';

            // Hide break adjustment section on reset
            const breakAdjustmentSection = document.getElementById('manualBreakAdjustment');
            if (breakAdjustmentSection) {
                breakAdjustmentSection.style.display = 'none';
            }

            // Reset variables
            schedule = {};
            isDayShift = true;
            timeSlots = [...dayShiftSlots];
        }

        // Function to add staff input
function addStaffInput() {
    const staffInputs = document.getElementById('staffInputs');

    const staffContainer = document.createElement('div');
    staffContainer.className = 'staff-container';

    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.placeholder = 'Enter HCW Name';
    newInput.className = 'staff-name';

    staffContainer.appendChild(newInput);
    staffInputs.appendChild(staffContainer);

    // Add event listener to the new input
    newInput.addEventListener('input', debounce(saveToLocalStorage, 300));

    saveToLocalStorage();
}

// Function to add patient input
function addPatientInput() {
    const patientInputs = document.getElementById('patientInputs');

    const patientContainer = document.createElement('div');
    patientContainer.className = 'patient-container';

    const inputWrapper = document.createElement('div');
    inputWrapper.style.display = 'flex';
    inputWrapper.style.alignItems = 'center';
    inputWrapper.style.gap = '10px';

    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.placeholder = 'Enter Patient Name';
    newInput.className = 'patient-name';

    const staffCountSelect = document.createElement('select');
    staffCountSelect.className = 'staff-count';

    const option1 = document.createElement('option');
    option1.value = 1;
    option1.textContent = '1:1';
    const option2 = document.createElement('option');
    option2.value = 2;
    option2.textContent = '2:1';
    const option3 = document.createElement('option');
    option3.value = 3;
    option3.textContent = '3:1';

    staffCountSelect.appendChild(option1);
    staffCountSelect.appendChild(option2);
    staffCountSelect.appendChild(option3);
    staffCountSelect.value = 1; // Default to 1:1

    inputWrapper.appendChild(newInput);
    inputWrapper.appendChild(staffCountSelect);
    patientContainer.appendChild(inputWrapper);
    patientInputs.appendChild(patientContainer);

    // Add event listeners to the new elements
    newInput.addEventListener('input', debounce(saveToLocalStorage, 300));
    staffCountSelect.addEventListener('change', debounce(saveToLocalStorage, 300));

    saveToLocalStorage();
}

// Function to check if time is restricted for security
function isSecurityRestrictedHour(timeIndex, totalHours) {
    // First 2 hours or last 2 hours
    return timeIndex < 2 || timeIndex >= totalHours - 2;
}

// Debug button functionality
document.getElementById('debugFillBtn').addEventListener('click', async function() {
    try {
        // Show loading message
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'error-message';
        loadingDiv.style.backgroundColor = '#3498db';
        loadingDiv.textContent = "Fetching random names...";
        document.body.appendChild(loadingDiv);

        // Count how many inputs we need to fill
        const staffInputCount = document.querySelectorAll('.staff-container .staff-name').length;
        const patientInputCount = document.querySelectorAll('.patient-container').length;
        const securityInputCount = document.querySelectorAll('.security-container .security-name').length;
        const nurseInputCount = 2; // We always have 2 nurse in charge inputs

        // Fetch random names from online API - specify English results only
        // Request exactly the number of names we need
        const staffResponse = await fetch(`https://randomuser.me/api/?results=${staffInputCount}&nat=us,gb`);
        const patientResponse = await fetch(`https://randomuser.me/api/?results=${patientInputCount}&nat=us,gb`);
        const securityResponse = await fetch(`https://randomuser.me/api/?results=${securityInputCount}&nat=us,gb`);
        const nurseResponse = await fetch(`https://randomuser.me/api/?results=${nurseInputCount}&nat=us,gb`);

        // Parse the responses
        const staffData = await staffResponse.json();
        const patientData = await patientResponse.json();
        const securityData = await securityResponse.json();
        const nurseData = await nurseResponse.json();

        // Extract names from the API responses
        const staffNames = staffData.results.map(user =>
            `${user.name.first} ${user.name.last}`
        );
        const patientNames = patientData.results.map((user, index) =>
            `Patient ${String.fromCharCode(65 + index)} - ${user.name.last}`
        );
        const securityNames = securityData.results.map(user =>
            `${user.name.first} ${user.name.last}`
        );
        const nurseNames = nurseData.results.map(user =>
            `${user.name.first} ${user.name.last}`
        );

        // Remove loading message
        loadingDiv.remove();

        // Fill nurse in charge inputs
        if (nurseNames.length >= 1) document.getElementById('nurseInChargeInput').value = nurseNames[0];
        if (nurseNames.length >= 2) document.getElementById('nurseInCharge2Input').value = nurseNames[1];

        // Fill all existing staff inputs
        document.querySelectorAll('.staff-container .staff-name').forEach((input, index) => {
            if (index < staffNames.length) {
                input.value = staffNames[index];
            }
        });

        // Fill all existing security staff inputs
        document.querySelectorAll('.security-container .security-name').forEach((input, index) => {
            if (index < securityNames.length) {
                input.value = securityNames[index];
            }
        });

        // Fill all existing patient inputs
        document.querySelectorAll('.patient-container').forEach((container, index) => {
            if (index < patientNames.length) {
                const nameInput = container.querySelector('.patient-name');
                const staffCountSelect = container.querySelector('.staff-count');

                nameInput.value = patientNames[index];
                staffCountSelect.value = (index % 3) + 1; // Cycle through 1, 2, 3
            }
        });

        // Show confirmation message
        const confirmationDiv = document.createElement('div');
        confirmationDiv.className = 'error-message';
        confirmationDiv.style.backgroundColor = '#4CAF50'; // Green for success
        confirmationDiv.textContent = "Debug data filled successfully with random names!";
        document.body.appendChild(confirmationDiv);
        setTimeout(() => confirmationDiv.remove(), 3000);

        // Save to localStorage
        saveToLocalStorage();
    } catch (error) {
        console.error("Error fetching random names:", error);

        // Show error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = "Failed to fetch random names. Using fallback names instead.";
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 5000);

        // Generate enough fallback names based on input counts
        const staffInputCount = document.querySelectorAll('.staff-container .staff-name').length;
        const patientInputCount = document.querySelectorAll('.patient-container').length;
        const securityInputCount = document.querySelectorAll('.security-container .security-name').length;

        // Create dynamic fallback names
        const staffNames = Array.from({length: staffInputCount}, (_, i) => `Staff Member ${i+1}`);
        const patientNames = Array.from({length: patientInputCount}, (_, i) =>
            `Patient ${String.fromCharCode(65 + i)}`);
        const securityNames = Array.from({length: securityInputCount}, (_, i) => `Security ${i+1}`);
        const nurseNames = ['Head Nurse 1', 'Head Nurse 2'];

        // Fill with fallback names
        document.getElementById('nurseInChargeInput').value = nurseNames[0];
        document.getElementById('nurseInCharge2Input').value = nurseNames[1];

        document.querySelectorAll('.staff-container .staff-name').forEach((input, index) => {
            if (index < staffNames.length) input.value = staffNames[index];
        });

        document.querySelectorAll('.security-container .security-name').forEach((input, index) => {
            if (index < securityNames.length) input.value = securityNames[index];
        });

        document.querySelectorAll('.patient-container').forEach((container, index) => {
            if (index < patientNames.length) {
                container.querySelector('.patient-name').value = patientNames[index];
                container.querySelector('.staff-count').value = (index % 3) + 1;
            }
        });

        saveToLocalStorage();
    }
});

// Add this comprehensive function to generate the schedule
function generateSchedule() {
    try {
        // Validate inputs before generating schedule
        if (!validateInputs()) {
            return;
        }

        // Check staff sufficiency and warn user if needed
        if (!checkStaffSufficiency()) {
            return;
        }

        // Get current values
        const staff = Array.from(document.querySelectorAll('.staff-name'))
            .map(input => input.value.trim())
            .filter(name => name); // Filter out empty names

        // Get security staff values
        const securityStaffValues = Array.from(document.querySelectorAll('.security-name'))
            .map(input => input.value.trim())
            .filter(name => name);

        // Update global security staff array for use in other functions
        securityStaff = [...securityStaffValues];

        // Get nurse in charge values and update globals
        nurseInCharge1 = document.getElementById('nurseInChargeInput').value.trim();
        nurseInCharge2 = document.getElementById('nurseInCharge2Input').value.trim();

        // Add nurses in charge to the staff list if they're not empty
        const allNurses = [];
        if (nurseInCharge1) {
            staff.push(nurseInCharge1);
            allNurses.push(nurseInCharge1);
        }
        if (nurseInCharge2) {
            staff.push(nurseInCharge2);
            allNurses.push(nurseInCharge2);
        }

        // Add security staff to the combined staff list
        const allStaff = [...staff, ...securityStaff];

        // Get patient inputs
        const patients = Array.from(document.querySelectorAll('.patient-container'))
            .map(container => {
                const name = container.querySelector('.patient-name').value.trim();
                if (!name) return null;

                return {
                    name,
                    staffCount: parseInt(container.querySelector('.staff-count').value)
                };
            })
            .filter(patient => patient !== null); // Filter out empty patients

        // Initialize schedule object with all time slots
        schedule = {};
        timeSlots.forEach(time => {
            schedule[time] = {
                patientAssignments: {},
                staffBreaks: {}
            };

            // Initialize patient assignments
            patients.forEach(patient => {
                schedule[time].patientAssignments[patient.name] = [];
            });

            // Initialize OBS (Ward Observation) assignment
            schedule[time].patientAssignments["OBS"] = [];
        });

        // Initialize staffPatientHistory if it doesn't exist
        if (!staffPatientHistory) {
            staffPatientHistory = {};
        }

        // Make sure all staff (including security) and patients have entries in staffPatientHistory
        allStaff.forEach(s => {
            if (!staffPatientHistory[s]) {
                staffPatientHistory[s] = {};
            }

            patients.forEach(patient => {
                if (staffPatientHistory[s][patient.name] === undefined) {
                    staffPatientHistory[s][patient.name] = 0;
                }
            });

            // Initialize OBS history for each staff member
            if (staffPatientHistory[s]["OBS"] === undefined) {
                staffPatientHistory[s]["OBS"] = 0;
            }
        });

        // Initialize stats object to track staff workload
        const staffStats = {};
        allStaff.forEach(s => {
            staffStats[s] = {
                workHours: 0,
                breakTime: 0,
                shortBreakTime: "",
                secondBreakTime: ""
            };
        });

        // Initialize continuous assignment tracker
        const continuousAssignmentTracker = {};
        allStaff.forEach(s => {
            continuousAssignmentTracker[s] = {};
            patients.forEach(patient => {
                continuousAssignmentTracker[s][patient.name] = 0;
            });
            // Initialize OBS tracking
            continuousAssignmentTracker[s]["OBS"] = 0;
        });

        // First, assign break times
        assignBreaks(allStaff, staffStats, patients);

        // Then, assign security duties for security staff (if any)
        assignSecurityDuties(securityStaff, staffStats);

        // Assign OBS (Ward Observation) duties
        assignObservationDuties(staff, securityStaff, nurseInCharge1, nurseInCharge2, staffStats);

        // Next, assign cleaning duties for night shift (if applicable)
        if (!isDayShift) {
            assignCleaningDuties(staff, securityStaff, nurseInCharge1, nurseInCharge2, staffStats);
        }

        // Finally, assign staff to patients using a fair algorithm
        assignPatients(staff, patients, staffStats, continuousAssignmentTracker);

        // Final validation to ensure no patients are left unassigned
        if (!validateScheduleCompleteness(schedule, patients)) {
            console.error("Schedule generation failed validation");
            return false;
        }

        // Make schedule globally accessible for popup functionality
        window.schedule = schedule;

        // Store original staffStats for reference during regeneration
        window.originalStaffStats = JSON.parse(JSON.stringify(staffStats));

        // Render the schedule
        renderSchedule(schedule, allStaff, patients.map(p => p.name), staffStats);

        // Render stats
        renderStats(staffStats, allStaff, patients.map(p => p.name), continuousAssignmentTracker);

        // Render rotation stats
        renderStaffRotationStats(
            patients.map(p => p.name),
            staff.filter(s => !securityStaffValues.includes(s))
        );

        // Show the manual break adjustment section after schedule generation
        const breakAdjustmentSection = document.getElementById('manualBreakAdjustment');
        if (breakAdjustmentSection) {
            breakAdjustmentSection.style.display = 'block';
        }

        // Save to localStorage
        saveToLocalStorage();

        return true;
    } catch (error) {
        console.error("Error generating schedule:", error);
        showError("An error occurred while generating the schedule. Please check your inputs and try again.");
        return false;
    }
}

// Sub-functions for generateSchedule

function validateInputs() {
    // Check if there are any staff members
    const staffInputs = Array.from(document.querySelectorAll('.staff-name'))
        .map(input => input.value.trim())
        .filter(name => name);

    if (staffInputs.length === 0) {
        showError("Please add at least one Health Care Worker.");
        return false;
    }

    // Check if there are any patients
    const patientInputs = Array.from(document.querySelectorAll('.patient-name'))
        .map(input => input.value.trim())
        .filter(name => name);

    if (patientInputs.length === 0) {
        showError("Please add at least one patient.");
        return false;
    }

    // Check if security staff is provided (mandatory)
    const securityStaffInputs = Array.from(document.querySelectorAll('.security-name'))
        .map(input => input.value.trim())
        .filter(name => name);

    if (securityStaffInputs.length === 0) {
        showError("Security Staff is mandatory. Please enter a security staff name.");
        return false;
    }

    // Check for duplicate staff names
    const allStaffInputs = [
        ...Array.from(document.querySelectorAll('.staff-name')).map(input => input.value.trim()),
        ...Array.from(document.querySelectorAll('.security-name')).map(input => input.value.trim()),
        document.getElementById('nurseInChargeInput').value.trim(),
        document.getElementById('nurseInCharge2Input').value.trim()
    ].filter(name => name);

    const uniqueStaff = new Set(allStaffInputs);
    if (uniqueStaff.size !== allStaffInputs.length) {
        showError("Each staff member must have a unique name. Please remove duplicates.");
        return false;
    }

    // Check for duplicate patient names
    const patientNames = Array.from(document.querySelectorAll('.patient-name'))
        .map(input => input.value.trim())
        .filter(name => name);

    const uniquePatients = new Set(patientNames);
    if (uniquePatients.size !== patientNames.length) {
        showError("Each patient must have a unique name. Please remove duplicates.");
        return false;
    }

    return true;
}

// Enhanced validation function to check staff sufficiency
function checkStaffSufficiency() {
    // Get all staff
    const staff = Array.from(document.querySelectorAll('.staff-name'))
        .map(input => input.value.trim())
        .filter(name => name);

    const securityStaffValues = Array.from(document.querySelectorAll('.security-name'))
        .map(input => input.value.trim())
        .filter(name => name);

    const nurseInCharge1 = document.getElementById('nurseInChargeInput').value.trim();
    const nurseInCharge2 = document.getElementById('nurseInCharge2Input').value.trim();

    // Calculate total staff available
    let totalStaff = staff.length + securityStaffValues.length;
    if (nurseInCharge1) totalStaff++;
    if (nurseInCharge2) totalStaff++;

    // Calculate total patient requirements
    const patients = Array.from(document.querySelectorAll('.patient-container'))
        .map(container => {
            const name = container.querySelector('.patient-name').value.trim();
            if (!name) return null;
            return {
                name,
                staffCount: parseInt(container.querySelector('.staff-count').value) || 1
            };
        })
        .filter(patient => patient !== null);

    const totalPatientRequirements = patients.reduce((total, patient) => total + patient.staffCount, 0);

    // Check if staff is insufficient and warn user
    if (totalStaff < totalPatientRequirements) {
        const message = `‚ö†Ô∏è WARNING: Insufficient Staff Detected!\n\n` +
                       `Total Staff Available: ${totalStaff}\n` +
                       `Total Patient Requirements: ${totalPatientRequirements}\n` +
                       `Staff Shortage: ${totalPatientRequirements - totalStaff}\n\n` +
                       `The system will generate a schedule anyway using emergency assignment protocols.\n` +
                       `Some staff may be overworked or assigned to multiple patients simultaneously.\n\n` +
                       `Consider adding more staff for optimal coverage.`;

        // Show warning but don't prevent schedule generation
        if (confirm(message + "\n\nDo you want to continue generating the schedule?")) {
            console.warn("Staff sufficiency warning acknowledged by user");
            return true;
        } else {
            return false;
        }
    }

    return true;
}

function assignBreaks(allStaff, staffStats, patients) {
    // Filter out nurses in charge from break assignments
    const staffForBreaks = allStaff.filter(s => s !== nurseInCharge1 && s !== nurseInCharge2);

    if (isDayShift) {
        // Day shift break logic - only for non-nurse-in-charge staff
        staffForBreaks.forEach(s => {
            // Assign 30-min break to a random hour between 9:00 and 13:00
            const shortBreakHour = Math.floor(Math.random() * 4) + 1; // 1 to 4 (9:00 to 13:00)
            schedule[timeSlots[shortBreakHour]].staffBreaks[s] = "30-MIN BREAK";
            staffStats[s].breakTime += 0.5;
            staffStats[s].shortBreakTime = timeSlots[shortBreakHour];

            // Assign 1-hour 2nd break to a random hour between 14:00 and 17:00
            const secondBreakHour = Math.floor(Math.random() * 4) + 6; // 6 to 9 (14:00 to 17:00)
            schedule[timeSlots[secondBreakHour]].staffBreaks[s] = "2ND BREAK";
            staffStats[s].breakTime += 1;
            staffStats[s].secondBreakTime = timeSlots[secondBreakHour];
        });

        // Set nurses in charge break times to "N/A" since they don't get scheduled breaks
        if (nurseInCharge1 && staffStats[nurseInCharge1]) {
            staffStats[nurseInCharge1].shortBreakTime = "N/A";
            staffStats[nurseInCharge1].secondBreakTime = "N/A";
        }
        if (nurseInCharge2 && staffStats[nurseInCharge2]) {
            staffStats[nurseInCharge2].shortBreakTime = "N/A";
            staffStats[nurseInCharge2].secondBreakTime = "N/A";
        }
    } else {
        // Night shift - INTELLIGENT break scheduling to prevent staffing conflicts

        // Calculate minimum staff needed at any time (all patients + OBS + security)
        const totalPatientRequirements = patients.reduce((total, patient) => total + patient.staffCount, 0);
        const minimumStaffNeeded = totalPatientRequirements + 1; // +1 for OBS duty

        console.log(`Night shift staffing analysis:`);
        console.log(`Total staff available: ${staffForBreaks.length}`);
        console.log(`Minimum staff needed at any time: ${minimumStaffNeeded}`);

        // Break time blocks: 00:00-02:00, 02:00-04:00, 04:00-06:00
        const breakTimeBlocks = [
            { start: 4, end: 5, name: "00:00-02:00" },  // 00:00-01:00, 01:00-02:00
            { start: 6, end: 7, name: "02:00-04:00" },  // 02:00-03:00, 03:00-04:00
            { start: 8, end: 9, name: "04:00-06:00" }   // 04:00-05:00, 05:00-06:00
        ];

        // SMART BREAK ALLOCATION: Ensure we never have too many staff on break
        const maxStaffOnBreakAtOnce = Math.max(1, staffForBreaks.length - minimumStaffNeeded);

        console.log(`Maximum staff allowed on break simultaneously: ${maxStaffOnBreakAtOnce}`);

        // If we can't safely give breaks to everyone, prioritize patient safety
        if (maxStaffOnBreakAtOnce < 1) {
            console.warn(`INSUFFICIENT STAFFING: Cannot provide breaks without compromising patient care`);
            console.warn(`Need at least ${minimumStaffNeeded + 1} staff for safe break rotation`);

            // Emergency: Only nurses-in-charge get no breaks, everyone else gets minimal breaks
            staffForBreaks.forEach(s => {
                staffStats[s].breakTime = 0;
                staffStats[s].shortBreakTime = "STAFFING SHORTAGE";
                staffStats[s].secondBreakTime = "UNABLE TO PROVIDE";
            });

            return; // Skip break allocation
        }

        // Safe break allocation - divide staff into groups that won't create conflicts
        const numberOfGroups = Math.ceil(staffForBreaks.length / maxStaffOnBreakAtOnce);
        const staffGroups = Array.from({ length: numberOfGroups }, () => []);

        // Distribute staff evenly across groups
        staffForBreaks.forEach((s, index) => {
            const groupIndex = index % numberOfGroups;
            staffGroups[groupIndex].push(s);
        });

        console.log(`Created ${numberOfGroups} break groups:`, staffGroups.map(g => g.length));

        // Assign 2-hour break blocks to each group
        staffGroups.forEach((group, groupIndex) => {
            // Only assign breaks if we have a corresponding break block
            if (groupIndex < breakTimeBlocks.length) {
                const breakBlock = breakTimeBlocks[groupIndex];

                // Assign breaks to all staff in this group for the full 2-hour block
                group.forEach(s => {
                    // First hour of 2-hour break block
                    schedule[timeSlots[breakBlock.start]].staffBreaks[s] = "NIGHT BREAK";

                    // Second hour of 2-hour break block
                    schedule[timeSlots[breakBlock.end]].staffBreaks[s] = "NIGHT BREAK";

                    // Update staff stats
                    staffStats[s].breakTime = 2; // Total break time is 2 hours

                    // Store break time info for display in table (show full block)
                    staffStats[s].shortBreakTime = breakBlock.name;
                    staffStats[s].secondBreakTime = "CONTINUOUS";

                    console.log(`Assigned ${s} to break block: ${breakBlock.name}`);
                });
            } else {
                // Staff in excess groups get shorter breaks or staggered breaks
                console.warn(`Group ${groupIndex + 1} cannot get full 2-hour break due to staffing constraints`);
                group.forEach(s => {
                    // Give them at least 1 hour break during the safest block (00:00-02:00)
                    const safeBreakIndex = breakTimeBlocks[0].start; // 00:00 hour
                    schedule[timeSlots[safeBreakIndex]].staffBreaks[s] = "SHORT NIGHT BREAK";

                    staffStats[s].breakTime = 1;
                    staffStats[s].shortBreakTime = timeSlots[safeBreakIndex];
                    staffStats[s].secondBreakTime = "NONE";
                });
            }
        });

        // Set nurses in charge break times to "N/A" since they don't get scheduled breaks
        if (nurseInCharge1 && staffStats[nurseInCharge1]) {
            staffStats[nurseInCharge1].shortBreakTime = "N/A";
            staffStats[nurseInCharge1].secondBreakTime = "N/A";
        }
        if (nurseInCharge2 && staffStats[nurseInCharge2]) {
            staffStats[nurseInCharge2].shortBreakTime = "N/A";
            staffStats[nurseInCharge2].secondBreakTime = "N/A";
        }
    }
}

function assignSecurityDuties(securityStaff, staffStats) {
    // Assign security duties for the first 2 and last 2 hours of the shift
    securityStaff.forEach(s => {
        const totalHours = timeSlots.length;
        for (let i = 0; i < totalHours; i++) {
            if (isSecurityRestrictedHour(i, totalHours)) {
                schedule[timeSlots[i]].staffBreaks[s] = "SECURITY DUTY";
            }
        }
    });
}

// Observation duties assignment
function assignObservationDuties(staff, securityStaff, nurseInCharge1, nurseInCharge2, staffStats) {
    // Find regular staff (not security staff and not nurse in charge)
    const regularStaff = staff.filter(s =>
        !securityStaff.includes(s) &&
        s !== nurseInCharge1 &&
        s !== nurseInCharge2
    );

    if (regularStaff.length === 0) {
        console.warn("No regular staff available for OBS duties");
        return;
    }

    const totalHours = timeSlots.length;

    // Initialize continuous assignment tracker for OBS
    const obsAssignmentTracker = {};
    regularStaff.forEach(s => {
        obsAssignmentTracker[s] = 0; // Track consecutive hours for each staff
    });

    // Track OBS assignment history for rotation
    if (!staffPatientHistory) {
        staffPatientHistory = {};
    }

    // Ensure all staff have OBS history initialized
    regularStaff.forEach(s => {
        if (!staffPatientHistory[s]) {
            staffPatientHistory[s] = {};
        }
        if (staffPatientHistory[s]["OBS"] === undefined) {
            staffPatientHistory[s]["OBS"] = 0;
        }
    });

    // Process each time slot for OBS assignment
    timeSlots.forEach((time, timeIndex) => {
        // Get available staff for this time slot (those not on break AND not assigned to patients)
        const availableStaff = regularStaff.filter(s =>
            !schedule[time].staffBreaks[s] &&
            !isStaffAlreadyAssigned(s, time, schedule)
        );

        let allAvailableStaff = availableStaff.length > 0 ? availableStaff :
            regularStaff.filter(s => !isStaffAlreadyAssigned(s, time, schedule));

        // For first 2 and last 2 hours, prefer continuity but still allow rotation
        const isFixedPeriod = timeIndex < 2 || timeIndex >= totalHours - 2;

        // If we have multiple staff, use fair rotation logic
        if (allAvailableStaff.length > 1) {
            // Sort staff based on assignment history and continuous hours
            const sortedStaff = [...allAvailableStaff].sort((a, b) => {
                // Continuous hours penalty (to prevent long continuous assignments)
                const continuousHoursA = obsAssignmentTracker[a] || 0;
                const continuousHoursB = obsAssignmentTracker[b] || 0;

                // Apply penalty for continuous assignments (more than 2 hours)
                const continuityPenaltyA = continuousHoursA >= 3 ? 1000 : (continuousHoursA >= 2 ? 100 : 0);
                const continuityPenaltyB = continuousHoursB >= 3 ? 1000 : (continuousHoursB >= 2 ? 100 : 0);

                // OBS assignment history (for fair rotation)
                const obsHistoryA = staffPatientHistory[a]["OBS"] || 0;
                const obsHistoryB = staffPatientHistory[b]["OBS"] || 0;

                // Overall workload
                const workloadA = staffStats[a] ? (staffStats[a].workHours || 0) : 0;
                const workloadB = staffStats[b] ? (staffStats[b].workHours || 0) : 0;

                // Combined score (lower is better)
                const scoreA = continuityPenaltyA + (obsHistoryA * 10) + workloadA;
                const scoreB = continuityPenaltyB + (obsHistoryB * 10) + workloadB;

                return scoreA - scoreB;
            });

            // Select the best candidate
            const selectedStaff = sortedStaff[0];
            schedule[time].patientAssignments["OBS"] = [selectedStaff];

            // Update tracking
            if (staffPatientHistory[selectedStaff]) {
                staffPatientHistory[selectedStaff]["OBS"]++;
            }

            // Update continuous assignment tracking
            regularStaff.forEach(s => {
                if (s === selectedStaff) {
                    obsAssignmentTracker[s] = (obsAssignmentTracker[s] || 0) + 1;
                } else {
                    obsAssignmentTracker[s] = 0; // Reset if not assigned
                }
            });

        } else if (allAvailableStaff.length === 1) {
            // Only one staff available
            const selectedStaff = allAvailableStaff[0];
            schedule[time].patientAssignments["OBS"] = [selectedStaff];

            // Update tracking
            if (staffPatientHistory[selectedStaff]) {
                staffPatientHistory[selectedStaff]["OBS"]++;
            }
            obsAssignmentTracker[selectedStaff] = (obsAssignmentTracker[selectedStaff] || 0) + 1;
        }
    });
}

function assignCleaningDuties(staff, securityStaff, nurseInCharge1, nurseInCharge2, staffStats) {
    // Find regular staff (not security staff and not nurse in charge)
    const regularStaff = staff.filter(s =>
        !securityStaff.includes(s) &&
        s !== nurseInCharge1 &&
        s !== nurseInCharge2
    );

    if (regularStaff.length > 0) {
        // Simplified approach: just assign duties to staff without time slots
        const dutyAssignments = [];

        // First, try to give at least one duty to each staff member
        const staffWithDuties = new Set();
        let dutyIndex = 0;

        // First pass: try to give at least one duty to each staff member
        regularStaff.forEach(s => {
            if (dutyIndex < cleaningDuties.length) {
                const duty = cleaningDuties[dutyIndex];

                // Store cleaning duty in the staff stats
                if (!staffStats[s].cleaningDuties) {
                    staffStats[s].cleaningDuties = [];
                }
                staffStats[s].cleaningDuties.push({
                    duty: duty
                });

                // Mark that this staff has at least one duty
                staffWithDuties.add(s);

                // Add to duty assignments
                dutyAssignments.push({
                    duty: duty,
                    staff: s
                });

                dutyIndex++;
            }
        });

        // Second pass: distribute any remaining duties, prioritizing staff with fewer duties
        while (dutyIndex < cleaningDuties.length) {
            // Calculate current duty count per staff
            const staffDutyCount = {};
            regularStaff.forEach(s => {
                staffDutyCount[s] = 0;
            });

            dutyAssignments.forEach(assignment => {
                staffDutyCount[assignment.staff]++;
            });

            // Sort staff by number of duties assigned (ascending)
            const staffByDutyCount = [...regularStaff].sort((a, b) => {
                return staffDutyCount[a] - staffDutyCount[b];
            });

            // Try to assign a duty to the staff with fewest duties
            if (staffByDutyCount.length > 0) {
                const s = staffByDutyCount[0];
                const duty = cleaningDuties[dutyIndex];

                // Store cleaning duty in the staff stats
                if (!staffStats[s].cleaningDuties) {
                    staffStats[s].cleaningDuties = [];
                }
                staffStats[s].cleaningDuties.push({
                    duty: duty
                });

                // Add to duty assignments
                dutyAssignments.push({
                    duty: duty,
                    staff: s
                });

                dutyIndex++;
            } else {
                break; // No staff available for more duties
            }
        }

        // Check if any staff still don't have duties
        const staffWithoutDuties = regularStaff.filter(s => !staffWithDuties.has(s));
        if (staffWithoutDuties.length > 0) {
            console.log(`The following staff have no cleaning duties assigned: ${staffWithoutDuties.join(', ')}`);

            // Store this information in staff stats
            staffWithoutDuties.forEach(s => {
                if (!staffStats[s].cleaningDuties) {
                    staffStats[s].cleaningDuties = [];
                }
                staffStats[s].noDutiesAssigned = true;
            });
        }

        // Add information about remaining unassigned duties to the stats
        const assignedDutyCount = dutyAssignments.length;
        const remainingDuties = cleaningDuties.slice(assignedDutyCount);
        if (remainingDuties.length > 0) {
            console.log(`Warning: ${remainingDuties.length} cleaning duties could not be assigned: ${remainingDuties.join(', ')}`);

            // Store this information
            staffStats.remainingDuties = remainingDuties;
        }
    }
}

// Enhanced assignPatients function with GUARANTEED patient coverage
function assignPatients(staff, patients, staffStats, continuousAssignmentTracker) {
    // Calculate total staff requirement across all patients
    const totalStaffRequired = patients.reduce((total, patient) => total + patient.staffCount, 0);

    console.log(`=== STAFFING ADEQUACY CHECK ===`);
    console.log(`Total staff required: ${totalStaffRequired}`);
    console.log(`Total regular staff available: ${staff.length}`);
    console.log(`Total security staff available: ${securityStaff.length}`);
    console.log(`Total staff pool: ${staff.length + securityStaff.length}`);

    // Process each time slot with multi-pass assignment to ensure no patient is left unassigned
    timeSlots.forEach((time, timeIndex) => {
        console.log(`\n=== Processing time slot: ${time} ===`);

        // PRE-ASSIGNMENT CHECK: Count how many staff are available at this time
        const staffOnBreak = staff.filter(s => schedule[time].staffBreaks[s]).length;
        const securityOnDuty = securityStaff.filter(s => schedule[time].staffBreaks[s] === "SECURITY DUTY").length;
        const staffAvailableForPatients = (staff.length - staffOnBreak) + (securityStaff.length - securityOnDuty);

        console.log(`Time ${time} staffing analysis:`);
        console.log(`  Regular staff on break: ${staffOnBreak}/${staff.length}`);
        console.log(`  Security staff on duty: ${securityOnDuty}/${securityStaff.length}`);
        console.log(`  Staff available for patients: ${staffAvailableForPatients}`);
        console.log(`  Staff required for patients: ${totalStaffRequired}`);

        if (staffAvailableForPatients < totalStaffRequired) {
            console.error(`üö® CRITICAL STAFFING SHORTAGE at ${time}:`);
            console.error(`  Need: ${totalStaffRequired} staff`);
            console.error(`  Have: ${staffAvailableForPatients} staff`);
            console.error(`  Shortage: ${totalStaffRequired - staffAvailableForPatients} staff`);
            console.error(`This will likely cause assignment conflicts!`);
        }
        console.log(`\n=== Processing time slot: ${time} ===`);

        // PASS 1: Try to assign with optimal staff (not on breaks)
        let passCount = 0;
        const maxPasses = 3;

        while (passCount < maxPasses) {
            passCount++;
            console.log(`Assignment Pass ${passCount} for ${time}`);

            // Get available staff based on pass number (expand pool each pass) - with CONFLICT CHECKING
            let availableStaff;
            if (passCount === 1) {
                // Pass 1: Only fully available staff (not on break, not on security duty, not assigned to OBS or other patients)
                const availableRegularStaff = staff.filter(s =>
                    !schedule[time].staffBreaks[s] &&
                    !isStaffAlreadyAssignedIncludingOBS(s, time, schedule)
                );
                const availableSecurityStaff = securityStaff.filter(s =>
                    (!schedule[time].staffBreaks[s] || schedule[time].staffBreaks[s] !== "SECURITY DUTY") &&
                    !isStaffAlreadyAssignedIncludingOBS(s, time, schedule)
                );
                availableStaff = [...availableRegularStaff, ...availableSecurityStaff];
            } else if (passCount === 2) {
                // Pass 2: Include staff on regular breaks if needed, but still check for other assignments
                const availableRegularStaff = staff.filter(s =>
                    (!schedule[time].staffBreaks[s] ||
                    (schedule[time].staffBreaks[s] !== "SECURITY DUTY")) &&
                    !isStaffAlreadyAssignedIncludingOBS(s, time, schedule)
                );
                const availableSecurityStaff = securityStaff.filter(s =>
                    schedule[time].staffBreaks[s] !== "SECURITY DUTY" &&
                    !isStaffAlreadyAssignedIncludingOBS(s, time, schedule)
                );
                availableStaff = [...availableRegularStaff, ...availableSecurityStaff];
            } else {
                // Pass 3: Emergency - use ALL staff if absolutely necessary, but warn about conflicts
                const allStaff = [...staff, ...securityStaff];
                availableStaff = allStaff.filter(s => !isStaffAlreadyAssignedIncludingOBS(s, time, schedule));

                // If still no staff available, allow conflicts but log warnings
                if (availableStaff.length === 0) {
                    console.warn(`EMERGENCY: No unassigned staff available at ${time}. Allowing conflicts.`);
                    availableStaff = allStaff;
                }
            }

            console.log(`Available staff in pass ${passCount}:`, availableStaff.length);

            // Sort patients by staffCount (highest first) to prioritize critical care
            const sortedPatients = [...patients].sort((a, b) => b.staffCount - a.staffCount);

            let allPatientsAssigned = true;

            // Attempt to assign staff to unassigned patients
            for (const patient of sortedPatients) {
                const currentAssigned = schedule[time].patientAssignments[patient.name] || [];
                const staffNeeded = patient.staffCount - currentAssigned.length;

                if (staffNeeded > 0) {
                    console.log(`Patient ${patient.name} needs ${staffNeeded} more staff`);

                    // Filter out staff already assigned to this patient
                    const unassignedStaff = availableStaff.filter(s => !currentAssigned.includes(s));
                    const staffToAssign = Math.min(staffNeeded, unassignedStaff.length);

                    if (staffToAssign > 0) {
                        // Find best staff for this patient
                        const bestStaff = findStaffWithContinuityLimit(
                            unassignedStaff,
                            patient.name,
                            staffToAssign,
                            staffStats,
                            continuousAssignmentTracker,
                            timeIndex
                        );

                        // Assign the staff
                        bestStaff.forEach(s => {
                            schedule[time].patientAssignments[patient.name].push(s);

                            // Update rotation history
                            if (!staffPatientHistory[s]) staffPatientHistory[s] = {};
                            if (!staffPatientHistory[s][patient.name]) staffPatientHistory[s][patient.name] = 0;
                            staffPatientHistory[s][patient.name]++;

                            // Update stats
                            staffStats[s].workHours++;

                            // Update continuous assignment tracker
                            if (timeIndex > 0) {
                                const prevTime = timeSlots[timeIndex - 1];
                                const prevAssignments = schedule[prevTime].patientAssignments[patient.name] || [];

                                if (prevAssignments.includes(s)) {
                                    continuousAssignmentTracker[s][patient.name]++;
                                } else {
                                    continuousAssignmentTracker[s][patient.name] = 1;
                                }
                            } else {
                                continuousAssignmentTracker[s][patient.name] = 1;
                            }

                            console.log(`Assigned ${s} to ${patient.name} at ${time}`);
                        });
                    } else {
                        allPatientsAssigned = false;
                        console.log(`Could not assign enough staff to ${patient.name}`);
                    }
                }
            }

            // If all patients are properly assigned, exit early
            if (allPatientsAssigned) {
                console.log(`All patients assigned in pass ${passCount}`);
                break;
            }
        }

        // EMERGENCY FINAL CHECK: Ensure NO patient is left unassigned
        console.log("=== EMERGENCY FINAL ASSIGNMENT CHECK ===");
        for (const patient of patients) {
            const currentAssigned = schedule[time].patientAssignments[patient.name] || [];
            const staffNeeded = patient.staffCount - currentAssigned.length;

            if (staffNeeded > 0) {
                console.log(`EMERGENCY: Patient ${patient.name} still needs ${staffNeeded} staff!`);

                // Get ALL available staff for emergency assignment
                const allAvailableStaff = [...staff, ...securityStaff].filter(s =>
                    !currentAssigned.includes(s)
                );

                // If we don't have enough unique staff, allow double-assignment as absolute last resort
                let emergencyStaff = allAvailableStaff.slice(0, staffNeeded);

                // ULTIMATE FAILSAFE: If still not enough staff, reuse existing staff
                if (emergencyStaff.length < staffNeeded) {
                    const additionalNeeded = staffNeeded - emergencyStaff.length;
                    const reusableStaff = [...staff, ...securityStaff].slice(0, additionalNeeded);
                    emergencyStaff = [...emergencyStaff, ...reusableStaff];
                    console.warn(`ULTIMATE FAILSAFE: Reusing ${additionalNeeded} staff for ${patient.name} at ${time}`);
                }

                emergencyStaff.forEach(s => {
                    schedule[time].patientAssignments[patient.name].push(s);

                    // Update basic tracking
                    if (!staffPatientHistory[s]) staffPatientHistory[s] = {};
                    if (!staffPatientHistory[s][patient.name]) staffPatientHistory[s][patient.name] = 0;
                    staffPatientHistory[s][patient.name]++;

                    staffStats[s].workHours++;
                    continuousAssignmentTracker[s][patient.name] = 1;

                    console.log(`EMERGENCY assigned ${s} to ${patient.name} at ${time}`);
                });
            }
        }

        console.log(`=== Completed time slot: ${time} ===\n`);
    });
}

// Helper function to check if a staff member is already assigned to any duty at a given time
function isStaffAlreadyAssigned(staffName, time, schedule) {
    // Check if assigned to any patient (not including OBS, since OBS is assigned first)
    for (const patientName in schedule[time].patientAssignments) {
        if (patientName !== "OBS") {
            const patientAssignments = schedule[time].patientAssignments[patientName] || [];
            if (patientAssignments.includes(staffName)) {
                return true;
            }
        }
    }

    return false;
}

// Helper function specifically for OBS assignment to check all conflicts including other OBS
function isStaffAlreadyAssignedIncludingOBS(staffName, time, schedule) {
    // Check if assigned to OBS
    const obsAssignments = schedule[time].patientAssignments["OBS"] || [];
    if (obsAssignments.includes(staffName)) {
        return true;
    }

    // Check if assigned to any patient
    for (const patientName in schedule[time].patientAssignments) {
        if (patientName !== "OBS") {
            const patientAssignments = schedule[time].patientAssignments[patientName] || [];
            if (patientAssignments.includes(staffName)) {
                return true;
            }
        }
    }

    return false;
}

// Add this new function to find staff with continuity limits
function findStaffWithContinuityLimit(availableStaff, patientName, count, staffStats, continuousTracker, timeIndex) {
    // Sort staff based on multiple factors
    const sorted = [...availableStaff].sort((a, b) => {
        // Continuous hours working with this patient
        const continuousHoursA = continuousTracker[a] ? (continuousTracker[a][patientName] || 0) : 0;
        const continuousHoursB = continuousTracker[b] ? (continuousTracker[b][patientName] || 0) : 0;

        // Apply strong penalty for staff with 3+ continuous hours (to force rotation)
        const continuityPenaltyA = continuousHoursA >= 3 ? 1000 : (continuousHoursA >= 2 ? 100 : 0);
        const continuityPenaltyB = continuousHoursB >= 3 ? 1000 : (continuousHoursB >= 2 ? 100 : 0);

        // Other factors from original algorithm
        const rotationA = (staffPatientHistory[a] && staffPatientHistory[a][patientName]) || 0;
        const rotationB = (staffPatientHistory[b] && staffPatientHistory[b][patientName]) || 0;

        const workloadA = staffStats[a] ? (staffStats[a].workHours || 0) : 0;
        const workloadB = staffStats[b] ? (staffStats[b].workHours || 0) : 0;

        const isSecurityA = securityStaff.includes(a) ? 10 : 0;
        const isSecurityB = securityStaff.includes(b) ? 10 : 0;

        // Apply penalty for nurses in charge if they have too many assignments
        const isNurseInChargeA = (a === nurseInCharge1 || a === nurseInCharge2) ? 1 : 0;
        const isNurseInChargeB = (b === nurseInCharge1 || b === nurseInCharge2) ? 1 : 0;

        // Heavy penalty for nurses in charge if they already have 3+ work hours (patient care assignments)
        const nurseInChargePenaltyA = isNurseInChargeA && workloadA >= 3 ? 2000 : (isNurseInChargeA ? 50 : 0);
        const nurseInChargePenaltyB = isNurseInChargeB && workloadB >= 3 ? 2000 : (isNurseInChargeB ? 50 : 0);

        // Combined score (lower is better for assignment)
        const scoreA = continuityPenaltyA + (rotationA * 5) + (workloadA * 2) + isSecurityA + nurseInChargePenaltyA;
        const scoreB = continuityPenaltyB + (rotationB * 5) + (workloadB * 2) + isSecurityB + nurseInChargePenaltyB;

        return scoreA - scoreB;
    });

    // Filter out nurses in charge who already have 3 or more patient care assignments
    const filteredStaff = sorted.filter(staffMember => {
        const isNurseInCharge = staffMember === nurseInCharge1 || staffMember === nurseInCharge2;
        if (isNurseInCharge) {
            const currentWorkHours = staffStats[staffMember] ? (staffStats[staffMember].workHours || 0) : 0;
            return currentWorkHours < 3; // Only allow nurses in charge if they have less than 3 assignments
        }
        return true; // Allow all other staff
    });

    return filteredStaff.slice(0, count);
}

function renderSchedule(schedule, staff, patients, staffStats) {
    // Clear previous schedule
    const scheduleHeader = document.getElementById('scheduleHeader');
    const scheduleBody = document.getElementById('scheduleBody');
    const staffHeader = document.getElementById('staffHeader');
    const staffBody = document.getElementById('staffBody');
    const breakHoursTable = document.getElementById('breakHoursTable').querySelector('tbody');

    scheduleHeader.innerHTML = '';
    scheduleBody.innerHTML = '';
    staffHeader.innerHTML = '';
    staffBody.innerHTML = '';
    breakHoursTable.innerHTML = '';

    // Create header for the patient schedule
    const headerRow = document.createElement('tr');

    // Add blank cell for the corner
    const cornerCell = document.createElement('th');
    headerRow.appendChild(cornerCell);

    // Add time slots as headers
    timeSlots.forEach(time => {
        const th = document.createElement('th');
        th.textContent = time;
        headerRow.appendChild(th);
    });

    scheduleHeader.appendChild(headerRow);

    // Add OBS (Ward Observation) row first
    const obsRow = document.createElement('tr');

    // Add OBS label cell
    const obsCell = document.createElement('td');
    obsCell.textContent = "OBS";
    obsCell.className = 'row-header';
    obsCell.style.fontWeight = "bold";
    obsRow.appendChild(obsCell);

    // Add cells for each time slot
    timeSlots.forEach(time => {
        const cell = document.createElement('td');
        cell.className = 'assignable-staff-cell';
        cell.setAttribute('data-time', time);
        cell.setAttribute('data-patient', "OBS");

        const assignedStaff = schedule[time]?.patientAssignments?.["OBS"] || [];

        if (assignedStaff.length === 0) {
            cell.textContent = "";
            cell.style.backgroundColor = "#f0f0f0"; // Light gray for unassigned OBS
            cell.style.color = "#666666";
        } else {
            // Display assigned staff for OBS
            const staffInitials = assignedStaff.map(staff => getInitials(staff)).join(', ');
            cell.textContent = staffInitials;
            cell.title = assignedStaff.join(", "); // Full names on hover

            // Add special styling for OBS - green background
            cell.style.backgroundColor = "#4CAF50"; // Green for OBS
            cell.style.color = "#ffffff"; // White text
            cell.style.fontWeight = "bold";
        }

        obsRow.appendChild(cell);
    });

    scheduleBody.appendChild(obsRow);

    // Create rows for each patient
    patients.forEach(patient => {
        const row = document.createElement('tr');

        // Add patient name as row header
        const nameCell = document.createElement('td');
        nameCell.textContent = patient;
        nameCell.className = 'row-header';
        row.appendChild(nameCell);

        // Add cells for each time slot
        timeSlots.forEach(time => {
            const cell = document.createElement('td');
            const assignedStaff = schedule[time].patientAssignments[patient];

            // Since our assignment algorithm guarantees all patients are assigned,
            // we should never see empty assignments. If somehow it happens, show a debug message.
            if (!assignedStaff || assignedStaff.length === 0) {
                cell.textContent = "ERROR: Contact Admin";
                cell.className = 'staff-unassigned assignable-staff-cell';
                cell.style.backgroundColor = '#ff6b6b';
                cell.style.color = 'white';
                console.error(`CRITICAL: Patient ${patient} not assigned at ${time}! This should never happen.`);
            } else {
                const staffInitials = assignedStaff.map(name => getInitials(name)).join(", ");
                cell.textContent = staffInitials;
                cell.title = assignedStaff.join(", ");
                cell.className = "assignable-staff-cell";

                // Add these data attributes to every cell
                cell.setAttribute("data-time", time);
                cell.setAttribute("data-patient", patient);

                // Color the cell based on the first assigned staff member
                if (assignedStaff.length > 0) {
                    // Generate a color based on the staff name
                    const staffName = assignedStaff[0];
                    const hash = staffName.split('').reduce((hash, char) => {
                        return ((hash << 5) - hash) + char.charCodeAt(0);
                    }, 0);

                    const hue = Math.abs(hash) % 360;
                    const bgColor = `hsl(${hue}, 70%, 85%)`;
                    const textColor = hue > 30 && hue < 200 ? '#000000' : '#ffffff';

                    cell.style.backgroundColor = bgColor;
                    cell.style.color = textColor;
                }
            }

            row.appendChild(cell);
        });

        scheduleBody.appendChild(row);
    });

    // Create header for the staff schedule
    const staffHeaderRow = document.createElement('tr');

    // Add blank cell for the corner
    const staffCornerCell = document.createElement('th');
    staffHeaderRow.appendChild(staffCornerCell);

    // Add time slots as headers
    timeSlots.forEach(time => {
        const th = document.createElement('th');
        th.textContent = time;
        staffHeaderRow.appendChild(th);
    });

    staffHeader.appendChild(staffHeaderRow);

    // Create rows for each staff member (excluding nursing staff)
    const nonNursingStaff = staff.filter(s => s !== nurseInCharge1 && s !== nurseInCharge2);
    nonNursingStaff.forEach(s => {
        const row = document.createElement('tr');

        // Add staff name cell with initials
        const staffCell = document.createElement('td');
        staffCell.textContent = getInitials(s);
        staffCell.title = s; // Add full name as tooltip
        staffCell.className = 'row-header';
        row.appendChild(staffCell);

        // Add cells for each time slot
        timeSlots.forEach(time => {
            const cell = document.createElement('td');

            // Check if the staff is on break during this time
            const breakStatus = schedule[time].staffBreaks[s];
            if (breakStatus === "30-MIN BREAK") {
                cell.textContent = "BREAK";
                cell.className = 'staff-break';
            } else if (breakStatus === "2ND BREAK") {
                cell.textContent = "2ND BREAK";
                cell.className = 'staff-lunch';
            } else if (breakStatus === "NIGHT BREAK") {
                cell.textContent = "BREAK";
                cell.style.backgroundColor = "#673ab7"; // Purple for night break
                cell.style.color = "#ffffff";
            } else if (breakStatus === "SECURITY DUTY") {
                cell.textContent = "SECURITY";
                cell.style.backgroundColor = "#ffccbc"; // Light orange for security duty
                cell.style.color = "#000000";
            } else if (breakStatus && cleaningDuties.includes(breakStatus)) {
                // This is for cleaning duties
                cell.textContent = breakStatus;
                cell.style.backgroundColor = "#9c27b0"; // Purple for cleaning duties
                cell.style.color = "#ffffff";
            } else {
                // Staff is not on break, find which patient they're assigned to
                let assigned = false;
                for (const patient of patients) {
                    if (schedule[time].patientAssignments[patient] &&
                        schedule[time].patientAssignments[patient].includes(s)) {
                        cell.textContent = getInitials(patient);
                        cell.title = patient; // Add patient name as tooltip

                        // Use consistent color based on staff
                        const hash = s.split('').reduce((hash, char) => {
                            return ((hash << 5) - hash) + char.charCodeAt(0);
                        }, 0);

                        const hue = Math.abs(hash) % 360;
                        const bgColor = `hsl(${hue}, 70%, 85%)`;
                        const textColor = hue > 30 && hue < 200 ? '#000000' : '#ffffff';

                        cell.style.backgroundColor = bgColor;
                        cell.style.color = textColor;

                        assigned = true;
                        break;
                    }
                }

                if (!assigned) {
                    cell.textContent = "FREE";
                    cell.style.backgroundColor = "#f8f9fa"; // Light gray for free time
                    cell.style.color = "#000000";
                }
            }

            row.appendChild(cell);
        });

        staffBody.appendChild(row);
    });

    // Render break hours table (excluding nursing staff)
    const nonNursingStaffForBreaks = staff.filter(s => s !== nurseInCharge1 && s !== nurseInCharge2);
    nonNursingStaffForBreaks.forEach(s => {
        const row = document.createElement('tr');

        // Staff name cell with initials
        const staffCell = document.createElement('td');
        staffCell.textContent = getInitials(s);
        staffCell.title = s; // Add full name as tooltip
        row.appendChild(staffCell);

        // Break time cells
        const shortBreakCell = document.createElement('td');
        shortBreakCell.textContent = staffStats[s].shortBreakTime || "N/A";
        row.appendChild(shortBreakCell);

        const secondBreakCell = document.createElement('td');
        secondBreakCell.textContent = staffStats[s].secondBreakTime || "N/A";
        row.appendChild(secondBreakCell);

        breakHoursTable.appendChild(row);
    });
}

function renderStats(staffStats, staff, patients, continuousAssignmentTracker) {
    const statsDiv = document.getElementById('stats');
    statsDiv.innerHTML = '';

    let statsHtml = '<h2>Staff Statistics</h2>';
    statsHtml += '<table>';
    statsHtml += '<tr><th>Staff</th><th>Work Hours</th><th>Break Time</th><th>Role</th></tr>';

    // Filter out nursing staff from statistics
    const nonNursingStaffForStats = staff.filter(s => s !== nurseInCharge1 && s !== nurseInCharge2);
    nonNursingStaffForStats.forEach(s => {
        // Determine staff role for display
        let roleDisplay = "Health Care Worker";
        let displayName = s;

        if (securityStaff.includes(s)) roleDisplay = "Security Staff";
        if (s === nurseInCharge1 || s === nurseInCharge2) {
            roleDisplay = "Nurse in Charge";
            displayName = "NIC";
        }

        statsHtml += `<tr>
            <td>${displayName}</td>
            <td>${staffStats[s].workHours}</td>
            <td>${staffStats[s].breakTime}</td>
            <td>${roleDisplay}</td>
        </tr>`;
    });

    statsHtml += '</table>';

    // Add a section summarizing security staff patient care
    const securityPatientCare = {};
    securityStaff.forEach(s => {
        securityPatientCare[s] = 0;
        if (staffStats[s] && staffStats[s].workHours) {
            securityPatientCare[s] = staffStats[s].workHours;
        }
    });

    if (securityStaff.length > 0) {
        statsHtml += '<h3>Security Staff Patient Care Summary</h3>';
        statsHtml += '<table>';
        statsHtml += '<tr><th>Security Staff</th><th>Security Duty Hours</th><th>Patient Care Hours</th></tr>';

        securityStaff.forEach(s => {
            const securityHours = 4; // Fixed security duty (first 2 and last 2 hours)
            const patientCareHours = securityPatientCare[s];

            statsHtml += `<tr>
                <td>${s}</td>
                <td>${securityHours}</td>
                <td>${patientCareHours}</td>
            </tr>`;
        });

        statsHtml += '</table>';
        statsHtml += '<p><em>Note: Security staff are assigned to security duty during the first 2 and last 2 hours of the shift.</em></p>';
    }

    // Add this to renderStats function, in the section for night shift
    if (!isDayShift) {
        // Add a cleaning duties summary
        statsHtml += '<h3>Night Shift Cleaning Duties Summary</h3>';
        statsHtml += '<table>';
        statsHtml += '<tr><th>Duty</th><th>Assigned To</th><th>Status</th></tr>';

        // Track duties
        const dutyAssignments = {};

        // Collect all assigned duties
        staff.forEach(s => {
            if (staffStats[s].cleaningDuties && staffStats[s].cleaningDuties.length > 0) {
                staffStats[s].cleaningDuties.forEach(item => {
                    dutyAssignments[item.duty] = {
                        staff: s
                    };
                });
            }
        });

        // List all cleaning duties and who they're assigned to
        cleaningDuties.forEach(duty => {
            const assignment = dutyAssignments[duty];
            if (assignment) {
                // Display "NIC" for nurses in charge
                const staffDisplayName = (assignment.staff === nurseInCharge1 || assignment.staff === nurseInCharge2) ? "NIC" : assignment.staff;
                const staffInitials = (assignment.staff === nurseInCharge1 || assignment.staff === nurseInCharge2) ? "NIC" : getInitials(assignment.staff);

                statsHtml += `<tr>
                    <td>${duty}</td>
                    <td class="cleaning-duty-assignable" data-duty="${duty}" style="cursor: pointer; color: var(--table-cell-text-color); font-weight: bold;" title="Click to reassign - ${assignment.staff}">${staffInitials} (${staffDisplayName})</td>
                    <td style="color: green;">‚úì Assigned</td>
                </tr>`;
            } else {
                statsHtml += `<tr>
                    <td>${duty}</td>
                    <td class="cleaning-duty-assignable" data-duty="${duty}" style="cursor: pointer; color: var(--table-cell-text-color); font-weight: bold;" title="Click to assign staff">Not Assigned</td>
                    <td style="color: red;">‚ö† Unassigned</td>
                </tr>`;
            }
        });

        // Show summary of staff without duties
        const staffWithoutDuties = staff.filter(s =>
            !securityStaff.includes(s) &&
            s !== nurseInCharge1 &&
            s !== nurseInCharge2 &&
            (!staffStats[s].cleaningDuties || staffStats[s].cleaningDuties.length === 0)
        );

        if (staffWithoutDuties.length > 0) {
            statsHtml += `<tr style="background-color: #fff3cd;">
                <td colspan="3">
                    <strong>Staff without cleaning duties:</strong> ${staffWithoutDuties.join(', ')}
                </td>
            </tr>`;
        }

        statsHtml += '</table>';
    }

    // Add this to the renderStats function, after the security staff section
    // Add a section showing continuous assignment tracking
    statsHtml += '<h3>Staff Continuity Report</h3>';
    statsHtml += '<p>This section shows the maximum number of continuous hours staff were assigned to the same patient.</p>';
    statsHtml += '<table>';
    statsHtml += '<tr><th>Staff</th><th>Patient</th><th>Max Continuous Hours</th><th>Status</th></tr>';

    // Calculate max continuous hours for display
    const maxContinuousHours = {};
    staff.forEach(s => {
        maxContinuousHours[s] = {};
        patients.forEach(patient => {
            const hours = continuousAssignmentTracker[s] ?
                (continuousAssignmentTracker[s][patient] || 0) : 0;
            maxContinuousHours[s][patient] = hours;
        });
    });

    // Display the longest continuous assignments
    let hasLongAssignments = false;
    staff.forEach(s => {
        patients.forEach(patient => {
            const hours = maxContinuousHours[s][patient];
            if (hours >= 2) { // Only show assignments of 2+ hours
                hasLongAssignments = true;
                const status = hours > 3 ?
                    '<span style="color: red;">Exceeds Target</span>' :
                    '<span style="color: green;">Within Target</span>';

                // Display "NIC" for nurses in charge
                const displayName = (s === nurseInCharge1 || s === nurseInCharge2) ? "NIC" : s;

                statsHtml += `<tr>
                    <td>${displayName}</td>
                    <td>${patient}</td>
                    <td>${hours}</td>
                    <td>${status}</td>
                </tr>`;
            }
        });
    });

    if (!hasLongAssignments) {
        statsHtml += '<tr><td colspan="4">No staff assigned to the same patient for more than 2 continuous hours.</td></tr>';
    }

    statsHtml += '</table>';
    statsHtml += '<p><em>Note: The target is to avoid assigning staff to the same patient for more than 3 continuous hours.</em></p>';

    statsDiv.innerHTML = statsHtml;
}

// Enhanced function to validate schedule completeness after generation
function validateScheduleCompleteness(schedule, patients) {
    console.log("=== FINAL SCHEDULE VALIDATION ===");
    let hasErrors = false;
    const errors = [];

    timeSlots.forEach(time => {
        patients.forEach(patient => {
            const assignedStaff = schedule[time].patientAssignments[patient.name] || [];
            const requiredStaff = patient.staffCount;

            if (assignedStaff.length === 0) {
                const error = `CRITICAL ERROR: Patient ${patient.name} has NO staff assigned at ${time}!`;
                console.error(error);
                errors.push(error);
                hasErrors = true;
            } else if (assignedStaff.length < requiredStaff) {
                const warning = `WARNING: Patient ${patient.name} has ${assignedStaff.length}/${requiredStaff} staff assigned at ${time}`;
                console.warn(warning);
                errors.push(warning);
            }
        });
    });    if (hasErrors) {
        showMessage("CRITICAL: Schedule validation failed! Some patients have no staff assigned. Please contact system administrator.", "error");
        return false;
    }

    if (errors.length > 0) {
        console.warn("Schedule generated with warnings:", errors);
        showMessage("‚ö†Ô∏è Schedule generated successfully! However, some patients have fewer staff than requested due to staff shortages. Emergency assignment protocols were used.", "warning");
    } else {
        console.log("‚úÖ Schedule validation passed - all patients have staff assigned!");
        showMessage("‚úÖ Schedule generated successfully! All patients have adequate staff coverage.", "success");
    }

    return true;
}

// Add this function to recalculate all statistics when manual staff changes are made
function regenerateScheduleStats() {
    // Get current values for staff and patients
    const allStaff = getAllStaffNames();
    const patients = getAllPatientNames();

    // Initialize staffStats object to track staff workload
    const staffStats = {};
    allStaff.forEach(s => {
        staffStats[s] = {
            workHours: 0,
            breakTime: 0,
            shortBreakTime: "",
            secondBreakTime: "",
            cleaningDuties: [] // Initialize cleaning duties array
        };
    });

    // Initialize continuous assignment tracker
    const continuousAssignmentTracker = {};
    allStaff.forEach(s => {
        continuousAssignmentTracker[s] = {};
        patients.forEach(patient => {
            continuousAssignmentTracker[s][patient] = 0;
        });
        // Initialize OBS tracking
        continuousAssignmentTracker[s]["OBS"] = 0;
    });

    // Restore break times and other assignments from the schedule object
    timeSlots.forEach((time, timeIndex) => {
        // Process break assignments
        if (schedule[time] && schedule[time].staffBreaks) {
            Object.keys(schedule[time].staffBreaks).forEach(staffName => {
                const breakType = schedule[time].staffBreaks[staffName];
                if (breakType && staffStats[staffName]) {
                    if (breakType === "30-MIN BREAK") {
                        staffStats[staffName].breakTime += 0.5;
                        if (!staffStats[staffName].shortBreakTime) {
                            staffStats[staffName].shortBreakTime = time;
                        }
                    } else if (breakType === "2ND BREAK") {
                        staffStats[staffName].breakTime += 1;
                        if (!staffStats[staffName].secondBreakTime) {
                            staffStats[staffName].secondBreakTime = time;
                        }
                    } else if (breakType === "NIGHT BREAK") {
                        staffStats[staffName].breakTime += 1;

                        // For night shift, group consecutive NIGHT BREAK hours into 2-hour blocks
                        if (!staffStats[staffName].nightBreakStart) {
                            // First hour of night break - store the start time
                            staffStats[staffName].nightBreakStart = time;
                            staffStats[staffName].shortBreakTime = time; // Temporary, will be updated when block completes
                        } else {
                            // Second hour of night break - create the full block time
                            const startTime = staffStats[staffName].nightBreakStart;
                            const endTime = time.split('-')[1]; // Get end time of current slot
                            const fullBlockTime = `${startTime.split('-')[0]}-${endTime}`;

                            // Update to show full 2-hour block
                            staffStats[staffName].shortBreakTime = fullBlockTime;
                            staffStats[staffName].secondBreakTime = "CONTINUOUS";

                            // Clean up temporary variable
                            delete staffStats[staffName].nightBreakStart;
                        }
                    }
                }
            });
        }

        // Count patient assignment work hours
        patients.forEach(patient => {
            const assignedStaff = schedule[time].patientAssignments[patient] || [];
            assignedStaff.forEach(staffMember => {
                if (staffStats[staffMember]) {
                    staffStats[staffMember].workHours++;
                }
            });
        });

        // Count OBS assignments
        const obsAssignedStaff = schedule[time].patientAssignments["OBS"] || [];
        obsAssignedStaff.forEach(staffMember => {
            if (staffStats[staffMember]) {
                staffStats[staffMember].workHours++;
            }
        });
    });

    // Restore cleaning duties from existing staffStats if available (for night shift)
    if (!isDayShift && window.originalStaffStats) {
        allStaff.forEach(s => {
            if (window.originalStaffStats[s] && window.originalStaffStats[s].cleaningDuties) {
                staffStats[s].cleaningDuties = [...window.originalStaffStats[s].cleaningDuties];
            }
        });
    }

    // Render the updated schedule and stats
    renderSchedule(schedule, allStaff, patients, staffStats);
    renderStats(staffStats, allStaff, patients, continuousAssignmentTracker);
    renderStaffRotationStats(patients, allStaff.filter(s => !securityStaff.includes(s)));

    // Save changes to localStorage
    saveToLocalStorage();
}

// Helper functions for getting staff and patient names
function getAllStaffNames() {
    const staff = Array.from(document.querySelectorAll('.staff-name'))
        .map(input => input.value.trim())
        .filter(name => name);

    const securityStaffValues = Array.from(document.querySelectorAll('.security-name'))
        .map(input => input.value.trim())
        .filter(name => name);

    const nurseInCharge1 = document.getElementById('nurseInChargeInput').value.trim();
    const nurseInCharge2 = document.getElementById('nurseInCharge2Input').value.trim();

    const allStaff = [...staff, ...securityStaffValues];
    if (nurseInCharge1) allStaff.push(nurseInCharge1);
    if (nurseInCharge2) allStaff.push(nurseInCharge2);

    return allStaff;
}

function getAllPatientNames() {
    return Array.from(document.querySelectorAll('.patient-name'))
        .map(input => input.value.trim())
        .filter(name => name);
}

// Initialize the application when page loads
window.onload = function() {
    // Set moon emoji for dark mode button
    document.getElementById('toggleModeBtn').innerHTML = 'üåô';

    // Load data from localStorage
    loadFromLocalStorage();

    // Add event listeners for all buttons
    document.getElementById('toggleModeBtn').addEventListener('click', function() {
        document.body.classList.toggle('dark-mode');
        this.textContent = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è' : 'üåô';
        saveToLocalStorage();
    });

    document.getElementById('toggleShiftBtn').addEventListener('click', function() {
        isDayShift = !isDayShift;
        timeSlots = isDayShift ? [...dayShiftSlots] : [...nightShiftSlots];
        document.getElementById('siteTitle').textContent = isDayShift ? "Day Shift Allocation" : "Night Shift Allocation";
        this.textContent = isDayShift ? "Switch to Night Shift" : "Switch to Day Shift";
        updateLegend();
        saveToLocalStorage();
    });

    document.getElementById('generateBtn').addEventListener('click', generateSchedule);

    document.getElementById('resetBtn').addEventListener('click', function() {
        clearAllData();
        localStorage.removeItem('patientCareData');
        addStaffInput();
        addPatientInput();
    });

    document.getElementById('addStaffBtn').addEventListener('click', addStaffInput);
    document.getElementById('removeStaffBtn').addEventListener('click', function() {
        const staffInputs = document.getElementById('staffInputs');
        if (staffInputs.children.length > 1) {
            staffInputs.removeChild(staffInputs.lastChild);
            saveToLocalStorage();
        }
    });

    document.getElementById('addPatientBtn').addEventListener('click', addPatientInput);
    document.getElementById('removePatientBtn').addEventListener('click', function() {
        const patientInputs = document.getElementById('patientInputs');
        if (patientInputs.children.length > 1) {
            patientInputs.removeChild(patientInputs.lastChild);
            saveToLocalStorage();
        }
    });

    document.getElementById('resetRotationBtn').addEventListener('click', function() {
        staffPatientHistory = {};
        showError("Rotation history has been reset!");
        saveToLocalStorage();
    });

    // Break adjustment event listeners
    document.getElementById('toggleBreakAdjustment').addEventListener('click', toggleBreakTimeEditing);
    document.getElementById('resetAllBreaks').addEventListener('click', resetAllBreakTimes);
    document.getElementById('saveBreakChanges').addEventListener('click', applyBreakTimeChanges);



    // Debug panel toggle button
    document.getElementById('toggleDebugBtn').addEventListener('click', function() {
        const debugPanel = document.getElementById('debugPanel');
        debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
    });

    // Debug panel clear button
    document.getElementById('clearDebugBtn').addEventListener('click', function() {
        document.getElementById('debugOutput').innerHTML = '';
    });

    // Initialize with one staff and patient input
    if (document.getElementById('staffInputs').children.length === 0) {
        addStaffInput();
    }
    if (document.getElementById('patientInputs').children.length === 0) {
        addPatientInput();
    }

    // Set up legend based on shift type
    updateLegend();
};

// jQuery document ready for popup functionality
$(document).ready(function() {
    // Open popup on cell click
    $(document).on('click', '.assignable-staff-cell', function() {
        // Get the time and patient from the clicked cell's data attributes
        const time = $(this).attr('data-time');
        const patient = $(this).attr('data-patient');

        console.log("Opening popup for:", time, patient);

        // Store these values on the popup element
        $('#staffPopup').data('time', time).data('patient', patient);

        // Get patient's required staff count for display
        let requiredStaffCount = 1; // Default
        let patientDisplayName = patient;

        if (patient !== "OBS") {
            const patientInputs = Array.from(document.querySelectorAll('.patient-container'));
            for (const container of patientInputs) {
                const patientName = container.querySelector('.patient-name').value.trim();
                if (patientName === patient) {
                    requiredStaffCount = parseInt(container.querySelector('.staff-count').value) || 1;
                    break;
                }
            }
        }

        // Update popup title to show staff requirements
        if (patient === "OBS") {
            $('#staffPopup h3').text('Select Staff for OBS (Ward Observation)');
        } else {
            $('#staffPopup h3').text(`Select Staff for ${patient} (${requiredStaffCount}:1 Care Ratio)`);
        }

        // Show overlay and popup
        $('#popupOverlay').show();
        $('#staffPopup').show();

        // List all available staff
        let staff = [];
        $('.staff-name').each(function() {
            const name = $(this).val().trim();
            if (name) staff.push(name);
        });

        // Add nurses in charge
        if ($('#nurseInChargeInput').val().trim()) staff.push($('#nurseInChargeInput').val().trim());
        if ($('#nurseInCharge2Input').val().trim()) staff.push($('#nurseInCharge2Input').val().trim());

        // Add security staff
        $('.security-name').each(function() {
            const name = $(this).val().trim();
            if (name) staff.push(name);
        });

        // Get currently assigned staff for this patient/time
        let currentlyAssigned = [];
        if (schedule && schedule[time] && schedule[time].patientAssignments && schedule[time].patientAssignments[patient]) {
            currentlyAssigned = schedule[time].patientAssignments[patient] || [];
        }

        // Build staff list with current assignments highlighted
        let html = '';

        // Add status header for regular patients
        if (patient !== "OBS") {
            const statusColor = currentlyAssigned.length === requiredStaffCount ? '#28a745' :
                               currentlyAssigned.length > requiredStaffCount ? '#dc3545' : '#ffc107';
            const statusText = currentlyAssigned.length === requiredStaffCount ? 'Optimal' :
                              currentlyAssigned.length > requiredStaffCount ? 'Over-assigned' : 'Under-assigned';

            html += `<div style="background-color: ${statusColor}; color: white; padding: 10px; margin-bottom: 10px; border-radius: 4px; text-align: center; font-weight: bold;">
                Current: ${currentlyAssigned.length}/${requiredStaffCount} staff (${statusText})
            </div>`;
        } else {
            // OBS status
            const obsStatus = currentlyAssigned.length > 0 ? 'Assigned' : 'Unassigned';
            const obsColor = currentlyAssigned.length > 0 ? '#28a745' : '#ffc107';
            html += `<div style="background-color: ${obsColor}; color: white; padding: 10px; margin-bottom: 10px; border-radius: 4px; text-align: center; font-weight: bold;">
                OBS Status: ${obsStatus}
            </div>`;
        }

        // Calculate total allocations for each staff member across all patients and time slots
        const staffAllocationCounts = {};
        staff.forEach(function(staffName) {
            let totalAllocations = 0;

            if (schedule) {
                timeSlots.forEach(time => {
                    if (schedule[time] && schedule[time].patientAssignments) {
                        // Count regular patient assignments
                        Object.keys(schedule[time].patientAssignments).forEach(patientName => {
                            const assignments = schedule[time].patientAssignments[patientName] || [];
                            if (assignments.includes(staffName)) {
                                totalAllocations++;
                            }
                        });
                    }
                });
            }

            staffAllocationCounts[staffName] = totalAllocations;
        });

        // Add staff buttons
        staff.forEach(function(name) {
            const isAssigned = currentlyAssigned.includes(name);
            const totalAllocations = staffAllocationCounts[name] || 0;
            let buttonStyle, buttonText, buttonClass;

            if (isAssigned) {
                // Currently assigned staff - green button
                buttonStyle = 'background-color: #28a745; color: white;';
                buttonText = `${name} (Currently Assigned) [${totalAllocations} total]`;
                buttonClass = 'select-staff-btn';
            } else if (patient !== "OBS" && currentlyAssigned.length >= requiredStaffCount) {
                // Patient at capacity - disabled style
                buttonStyle = 'background-color: #6c757d; color: white; opacity: 0.6;';
                buttonText = `${name} (Patient at capacity) [${totalAllocations} total]`;
                buttonClass = 'select-staff-btn';
            } else {
                // Available for assignment
                buttonStyle = 'background-color: var(--button-bg-color); color: white;';
                buttonText = `${name} [${totalAllocations} total allocations]`;
                buttonClass = 'select-staff-btn';
            }

            html += `<button class="${buttonClass}" data-name="${name}"
                     style="width: 100%; margin-bottom: 8px; padding: 10px; text-align: left;
                     ${buttonStyle} border: none; border-radius: 4px; cursor: pointer;">${buttonText}</button>`;
        });
        $('#staffList').html(html);
    });

    // Close popup functions
    function closePopup() {
        $('#popupOverlay').hide();
        $('#staffPopup').hide();
        $('#cleaningDutyPopup').hide(); // Also close cleaning duty popup
    }

    // Close popup on overlay click
    $('#popupOverlay').click(closePopup);

    // Close popup on Cancel button click
    $('#closePopupBtn').click(closePopup);    // Select staff button click handler - Toggle assignment
    $(document).on('click', '.select-staff-btn', function() {
        const staffName = $(this).attr('data-name');
        const time = $('#staffPopup').data('time');
        const patient = $('#staffPopup').data('patient');

        console.log("Toggling staff:", staffName, "for patient:", patient, "at time:", time);

        // Special handling for OBS (no staff limits)
        if (patient === "OBS") {
            // OBS can only have one staff member at a time
            if (schedule && schedule[time] && schedule[time].patientAssignments) {
                if (!schedule[time].patientAssignments[patient]) {
                    schedule[time].patientAssignments[patient] = [];
                }

                const currentAssignments = schedule[time].patientAssignments[patient];
                const staffIndex = currentAssignments.indexOf(staffName);

                if (staffIndex > -1) {
                    // Remove staff from OBS
                    currentAssignments.splice(staffIndex, 1);
                    console.log(`Removed ${staffName} from OBS`);
                } else {
                    // CRITICAL: Check if staff is already assigned to other patients at this time
                    if (isStaffAlreadyAssigned(staffName, time, schedule)) {
                        // Find out what patients they're assigned to
                        let conflictDetails = [];

                        // Check patient assignments
                        for (const otherPatient in schedule[time].patientAssignments) {
                            if (otherPatient !== "OBS") {
                                const otherAssignments = schedule[time].patientAssignments[otherPatient] || [];
                                if (otherAssignments.includes(staffName)) {
                                    conflictDetails.push(otherPatient);
                                }
                            }
                        }

                        alert(`‚ùå SCHEDULING CONFLICT!\n\n${staffName} is already assigned to: ${conflictDetails.join(", ")}\n\nStaff cannot be assigned to multiple jobs at the same time.\n\nPlease remove them from their current assignment first.`);
                        console.warn(`Cannot assign ${staffName} to OBS: already assigned to ${conflictDetails.join(", ")}`);
                        return; // Don't add the staff
                    }

                    // For OBS, replace any existing assignment with the new one
                    schedule[time].patientAssignments[patient] = [staffName];
                    console.log(`Assigned ${staffName} to OBS (replaced any existing assignment)`);
                }

                regenerateScheduleStats();
            }
        } else {
            // Regular patient - check staff ratio limits
            // Get patient's required staff count
            let requiredStaffCount = 1; // Default to 1:1
            const patientInputs = Array.from(document.querySelectorAll('.patient-container'));

            for (const container of patientInputs) {
                const patientName = container.querySelector('.patient-name').value.trim();
                if (patientName === patient) {
                    requiredStaffCount = parseInt(container.querySelector('.staff-count').value) || 1;
                    break;
                }
            }

            // Update the assignment in schedule object
            if (schedule && schedule[time] && schedule[time].patientAssignments) {
                // Make sure patient entry exists
                if (!schedule[time].patientAssignments[patient]) {
                    schedule[time].patientAssignments[patient] = [];
                }

                const currentAssignments = schedule[time].patientAssignments[patient];
                const staffIndex = currentAssignments.indexOf(staffName);

                if (staffIndex > -1) {
                    // Staff is currently assigned, remove them
                    currentAssignments.splice(staffIndex, 1);
                    console.log(`Removed ${staffName} from assignment`);
                } else {
                    // Check if adding this staff would exceed the required ratio
                    if (currentAssignments.length >= requiredStaffCount) {
                        // Show warning message
                        alert(`‚ö†Ô∏è Patient ${patient} requires ${requiredStaffCount}:1 care ratio.\n\nCurrent assignments: ${currentAssignments.length}/${requiredStaffCount}\n\nCannot add more staff. Remove existing staff first if you want to reassign.`);
                        console.warn(`Cannot assign ${staffName} to ${patient}: would exceed ${requiredStaffCount}:1 ratio`);
                        return; // Don't add the staff
                    }

                    // CRITICAL: Check if staff is already assigned to other patients or OBS at this time
                    if (isStaffAlreadyAssignedIncludingOBS(staffName, time, schedule)) {
                        // Find out what they're assigned to
                        let conflictDetails = [];

                        // Check OBS assignment
                        if (schedule[time].patientAssignments["OBS"] && schedule[time].patientAssignments["OBS"].includes(staffName)) {
                            conflictDetails.push("OBS (Ward Observation)");
                        }

                        // Check other patient assignments
                        for (const otherPatient in schedule[time].patientAssignments) {
                            if (otherPatient !== patient && otherPatient !== "OBS") {
                                const otherAssignments = schedule[time].patientAssignments[otherPatient] || [];
                                if (otherAssignments.includes(staffName)) {
                                    conflictDetails.push(otherPatient);
                                }
                            }
                        }

                        alert(`‚ùå SCHEDULING CONFLICT!\n\n${staffName} is already assigned to: ${conflictDetails.join(", ")}\n\nStaff cannot be assigned to multiple jobs at the same time.\n\nPlease remove them from their current assignment first.`);
                        console.warn(`Cannot assign ${staffName} to ${patient}: already assigned to ${conflictDetails.join(", ")}`);
                        return; // Don't add the staff
                    }

                    // Staff is not assigned and within limits, add them
                    currentAssignments.push(staffName);
                    console.log(`Added ${staffName} to assignment (${currentAssignments.length}/${requiredStaffCount})`);
                }

                // Regenerate all stats and redraw tables
                regenerateScheduleStats();
            } else {
                console.error("Cannot update schedule - schedule object structure is invalid", schedule);
            }
        }

        // Close popup after assignment
        $('#popupOverlay').hide();
        $('#staffPopup').hide();
    });

    // Remove all staff button click handler
    $('#removeAllStaffBtn').click(function() {
        const time = $('#staffPopup').data('time');
        const patient = $('#staffPopup').data('patient');

        console.log("Removing all staff for", patient, "at", time);

        // Clear the assignment in your schedule object
        if (schedule && schedule[time] && schedule[time].patientAssignments[patient]) {
            schedule[time].patientAssignments[patient] = [];

            // Regenerate all stats and redraw tables
            regenerateScheduleStats();
        }

        // Close popup
        $('#popupOverlay').hide();
        $('#staffPopup').hide();
    });

    // Cleaning Duty Assignment Popup Functionality
    $(document).on('click', '.cleaning-duty-assignable', function() {
        const duty = $(this).attr('data-duty');

        console.log("Opening cleaning duty popup for:", duty);

        // Store duty on popup element
        $('#cleaningDutyPopup').data('duty', duty);

        // Update popup title
        $('#cleaningDutyTitle').text(duty);

        // Show overlay and popup
        $('#popupOverlay').show();
        $('#cleaningDutyPopup').show();

        // Get available staff (regular staff only, no security or nurses in charge)
        let availableStaff = [];
        $('.staff-name').each(function() {
            const name = $(this).val().trim();
            if (name) availableStaff.push(name);
        });

        // Filter out security staff and nurses in charge
        const securityStaffNames = [];
        $('.security-name').each(function() {
            const name = $(this).val().trim();
            if (name) securityStaffNames.push(name);
        });

        const nurseInCharge1 = $('#nurseInChargeInput').val().trim();
        const nurseInCharge2 = $('#nurseInCharge2Input').val().trim();

        availableStaff = availableStaff.filter(name =>
            !securityStaffNames.includes(name) &&
            name !== nurseInCharge1 &&
            name !== nurseInCharge2
        );

        // Find currently assigned staff for this duty
        let currentlyAssigned = null;
        if (window.originalStaffStats) {
            for (const staffName in window.originalStaffStats) {
                if (window.originalStaffStats[staffName].cleaningDuties) {
                    const assignedDuty = window.originalStaffStats[staffName].cleaningDuties.find(d => d.duty === duty);
                    if (assignedDuty) {
                        currentlyAssigned = staffName;
                        break;
                    }
                }
            }
        }

        // Build staff list
        let html = '';

        // Status header
        const statusColor = currentlyAssigned ? '#28a745' : '#ffc107';
        const displayName = (currentlyAssigned === nurseInCharge1 || currentlyAssigned === nurseInCharge2) ? "NIC" : currentlyAssigned;
        const statusText = currentlyAssigned ? `Currently assigned to: ${displayName}` : 'Not assigned';
        html += `<div style="background-color: ${statusColor}; color: white; padding: 10px; margin-bottom: 10px; border-radius: 4px; text-align: center; font-weight: bold;">
            ${statusText}
        </div>`;

        // Calculate current cleaning duty count for each staff
        const staffDutyCount = {};
        availableStaff.forEach(staffName => {
            staffDutyCount[staffName] = 0;
            if (window.originalStaffStats && window.originalStaffStats[staffName] && window.originalStaffStats[staffName].cleaningDuties) {
                staffDutyCount[staffName] = window.originalStaffStats[staffName].cleaningDuties.length;
            }
        });

        // Add staff buttons
        availableStaff.forEach(function(name) {
            const isAssigned = currentlyAssigned === name;
            const dutyCount = staffDutyCount[name] || 0;
            let buttonStyle, buttonText, buttonClass;

            if (isAssigned) {
                buttonStyle = 'background-color: #28a745; color: white;';
                buttonText = `${name} (Currently Assigned) [${dutyCount} duties]`;
                buttonClass = 'select-cleaning-staff-btn';
            } else {
                buttonStyle = 'background-color: #9c27b0; color: white;';
                buttonText = `${name} [${dutyCount} current duties]`;
                buttonClass = 'select-cleaning-staff-btn';
            }

            html += `<button class="${buttonClass}" data-name="${name}"
                     style="width: 100%; margin-bottom: 8px; padding: 10px; text-align: left;
                     ${buttonStyle} border: none; border-radius: 4px; cursor: pointer;">${buttonText}</button>`;
        });

        $('#cleaningStaffList').html(html);
    });

    // Close cleaning duty popup functions
    function closeCleaningPopup() {
        $('#popupOverlay').hide();
        $('#cleaningDutyPopup').hide();
    }

    // Close cleaning popup on Cancel button click
    $('#closeCleaningPopupBtn').click(closeCleaningPopup);

    // Select cleaning staff button click handler
    $(document).on('click', '.select-cleaning-staff-btn', function() {
        const staffName = $(this).attr('data-name');
        const duty = $('#cleaningDutyPopup').data('duty');

        console.log("Assigning cleaning duty:", duty, "to staff:", staffName);

        // Update the staff stats
        if (window.originalStaffStats) {
            // First, remove this duty from any other staff member
            for (const existingStaffName in window.originalStaffStats) {
                if (window.originalStaffStats[existingStaffName].cleaningDuties) {
                    window.originalStaffStats[existingStaffName].cleaningDuties =
                        window.originalStaffStats[existingStaffName].cleaningDuties.filter(d => d.duty !== duty);
                }
            }

            // Add the duty to the selected staff member
            if (!window.originalStaffStats[staffName]) {
                window.originalStaffStats[staffName] = { cleaningDuties: [] };
            }
            if (!window.originalStaffStats[staffName].cleaningDuties) {
                window.originalStaffStats[staffName].cleaningDuties = [];
            }

            window.originalStaffStats[staffName].cleaningDuties.push({ duty: duty });

            // Regenerate stats to reflect changes
            regenerateScheduleStats();
        }

        // Close popup
        closeCleaningPopup();
    });

    // Remove cleaning staff assignment button click handler
    $('#removeCleaningStaffBtn').click(function() {
        const duty = $('#cleaningDutyPopup').data('duty');

        console.log("Removing cleaning duty assignment for:", duty);

        // Remove this duty from all staff members
        if (window.originalStaffStats) {
            for (const staffName in window.originalStaffStats) {
                if (window.originalStaffStats[staffName].cleaningDuties) {
                    window.originalStaffStats[staffName].cleaningDuties =
                        window.originalStaffStats[staffName].cleaningDuties.filter(d => d.duty !== duty);
                }
            }

            // Regenerate stats to reflect changes
            regenerateScheduleStats();
        }

        // Close popup
        closeCleaningPopup();
    });
});

// =========================
// BREAK TIME ADJUSTMENT FUNCTIONALITY
// =========================
// BREAK TIME ADJUSTMENT FUNCTIONALITY
// =========================

let breakEditingEnabled = false;
let originalBreakTimes = {};

function toggleBreakTimeEditing() {
    const button = document.getElementById('toggleBreakAdjustment');
    const tableContainer = document.getElementById('breakAdjustmentTable');
    const resetBtn = document.getElementById('resetAllBreaks');
    const saveBtn = document.getElementById('saveBreakChanges');

    if (!breakEditingEnabled) {
        // Enable editing mode
        breakEditingEnabled = true;
        button.textContent = 'Disable Break Time Editing';
        tableContainer.style.display = 'block';
        resetBtn.style.display = 'inline-block';
        saveBtn.style.display = 'inline-block';

        // Store original break times for reset functionality
        storeOriginalBreakTimes();

        // Populate the editable break table
        populateEditableBreakTable();
    } else {
        // Disable editing mode
        breakEditingEnabled = false;
        button.textContent = 'Enable Break Time Editing';
        tableContainer.style.display = 'none';
        resetBtn.style.display = 'none';
        saveBtn.style.display = 'none';
    }
}

function storeOriginalBreakTimes() {
    originalBreakTimes = {};
    if (window.originalStaffStats) {
        for (const staffName in window.originalStaffStats) {
            const staff = window.originalStaffStats[staffName];
            originalBreakTimes[staffName] = {
                shortBreakTime: staff.shortBreakTime || 'N/A',
                secondBreakTime: staff.secondBreakTime || 'N/A'
            };
        }
    }
}

function populateEditableBreakTable() {
    const tbody = document.getElementById('editableBreakTable').querySelector('tbody');
    tbody.innerHTML = '';

    // Update headers based on shift type
    const secondBreakHeader = document.getElementById('secondBreakHeader');
    const actionHeaders = document.querySelectorAll('#editableBreakTable th:last-child');

    if (isDayShift) {
        document.getElementById('firstBreakHeader').textContent = '30-min Break';
        secondBreakHeader.textContent = '1-hour 2nd Break';
        secondBreakHeader.style.display = ''; // Show second break column
        actionHeaders.forEach(header => header.style.display = ''); // Show actions column
    } else {
        document.getElementById('firstBreakHeader').textContent = '2-Hour Night Break';
        secondBreakHeader.style.display = 'none'; // Hide second break column for night shift
        actionHeaders.forEach(header => header.style.display = ''); // Keep actions column visible
    }

    if (!window.originalStaffStats) {
        const colspan = isDayShift ? '4' : '3'; // Adjust colspan based on shift type
        tbody.innerHTML = `<tr><td colspan="${colspan}">No schedule generated yet. Please generate a schedule first.</td></tr>`;
        return;
    }

    const allStaff = Object.keys(window.originalStaffStats);
    // For night shift, only use 00:00, 02:00, 04:00 as break options
    const timeOptions = isDayShift ? getAvailableTimeSlots() : ["00:00", "02:00", "04:00"];

    // Filter out nursing staff from break adjustment table
    const nonNursingStaff = allStaff.filter(staffName =>
        staffName !== nurseInCharge1 && staffName !== nurseInCharge2
    );

    nonNursingStaff.forEach(staffName => {
        const staff = window.originalStaffStats[staffName];
        const shortBreak = staff.shortBreakTime || 'N/A';
        const secondBreak = staff.secondBreakTime || 'N/A';

        const row = document.createElement('tr');
        row.setAttribute('data-staff', staffName);

        if (isDayShift) {
            // Day shift: Show both break columns
            row.innerHTML = `
                <td><strong>${staffName}</strong></td>
                <td>
                    ${shortBreak === 'N/A' ?
                        '<span>N/A (Nurse in Charge)</span>' :
                        `<select class="break-time-select" data-break-type="short">${generateTimeOptions(timeOptions, shortBreak)}</select>`
                    }
                </td>
                <td>
                    ${secondBreak === 'N/A' ?
                        '<span>N/A (Nurse in Charge)</span>' :
                        `<select class="break-time-select" data-break-type="second">${generateTimeOptions(timeOptions, secondBreak)}</select>`
                    }
                </td>
                <td>
                    <div class="staff-break-actions">
                        ${(shortBreak !== 'N/A' && secondBreak !== 'N/A') ?
                            `<button class="reset-staff-btn" onclick="resetStaffBreaks('${staffName}')">Reset</button>` :
                            '<span>-</span>'
                        }
                    </div>
                </td>
            `;
        } else {
            // Night shift: Show only one break column (use shortBreak as the main break)
            const nightBreak = shortBreak !== 'N/A' ? shortBreak : secondBreak;
            row.innerHTML = `
                <td><strong>${staffName}</strong></td>
                <td>
                    ${nightBreak === 'N/A' ?
                        '<span>N/A (Nurse in Charge)</span>' :
                        `<select class="break-time-select" data-break-type="night">${["00:00", "02:00", "04:00"].map(time => `<option value="${time}" ${nightBreak === time ? 'selected' : ''}>${time}</option>`).join('')}</select>`
                    }
                </td>
                <td>
                    <div class="staff-break-actions">
                        ${nightBreak !== 'N/A' ?
                            `<button class="reset-staff-btn" onclick="resetStaffBreaks('${staffName}')">Reset</button>` :
                            '<span>-</span>'
                        }
                    </div>
                </td>
            `;
        }

        tbody.appendChild(row);
    });
}

function getAvailableTimeSlots() {
    return [...timeSlots]; // Use the global timeSlots array directly
}

function getSimplifiedNightTimeSlots() {
    // Return simplified time format for night shift: just the hour (00:00, 02:00, 04:00, etc.)
    return timeSlots.map(timeSlot => {
        // Extract the hour from time format like "22:00-23:00" and return just "22:00"
        return timeSlot.split('-')[0];
    });
}

function generateTimeOptions(timeSlots, selectedTime) {
    let options = '';
    timeSlots.forEach(timeSlot => {
        const selected = timeSlot === selectedTime ? 'selected' : '';
        options += `<option value="${timeSlot}" ${selected}>${timeSlot}</option>`;
    });
    return options;
}

function generateSimplifiedTimeOptions(timeSlots, selectedTime) {
    let options = '';
    timeSlots.forEach(timeSlot => {
        const selected = timeSlot === selectedTime || timeSlot === selectedTime.split('-')[0] ? 'selected' : '';
        // Display simplified format but store the original format for compatibility
        const displayTime = timeSlot;
        const storeTime = isDayShift ? timeSlot : timeSlot;
        options += `<option value="${storeTime}" ${selected}>${displayTime}</option>`;
    });
    return options;
}

function resetStaffBreaks(staffName) {
    if (originalBreakTimes[staffName]) {
        const original = originalBreakTimes[staffName];
        const row = document.querySelector(`tr[data-staff="${staffName}"]`);

        if (isDayShift) {
            // Day shift: Reset both break selects
            const shortSelect = row.querySelector('select[data-break-type="short"]');
            const secondSelect = row.querySelector('select[data-break-type="second"]');

            if (shortSelect) shortSelect.value = original.shortBreakTime;
            if (secondSelect) secondSelect.value = original.secondBreakTime;
        } else {
            // Night shift: Reset single break select
            const nightSelect = row.querySelector('select[data-break-type="night"]');
            if (nightSelect) {
                const originalBreak = original.shortBreakTime !== 'N/A' ? original.shortBreakTime : original.secondBreakTime;
                nightSelect.value = originalBreak;
            }
        }
    }
}

function resetAllBreakTimes() {
    if (confirm('Are you sure you want to reset all break times to their original values?')) {
        Object.keys(originalBreakTimes).forEach(staffName => {
            resetStaffBreaks(staffName);
        });
    }
}

function applyBreakTimeChanges() {
    if (!window.originalStaffStats || !window.schedule) {
        alert('No schedule to update. Please generate a schedule first.');
        return;
    }

    const changes = {};
    let hasChanges = false;

    // Collect all changes from the editable table
    const rows = document.querySelectorAll('#editableBreakTable tbody tr');
    rows.forEach(row => {
        const staffName = row.getAttribute('data-staff');

        if (isDayShift) {
            // Day shift: Handle both breaks
            const shortBreakSelect = row.querySelector('select[data-break-type="short"]');
            const secondBreakSelect = row.querySelector('select[data-break-type="second"]');

            if (shortBreakSelect && secondBreakSelect) {
                const newShortBreak = shortBreakSelect.value;
                const newSecondBreak = secondBreakSelect.value;
                const original = originalBreakTimes[staffName];

                if (original && (newShortBreak !== original.shortBreakTime || newSecondBreak !== original.secondBreakTime)) {
                    changes[staffName] = {
                        oldShort: original.shortBreakTime,
                        oldSecond: original.secondBreakTime,
                        newShort: newShortBreak,
                        newSecond: newSecondBreak
                    };
                    hasChanges = true;
                }
            }
        } else {
            // Night shift: Handle single break
            const nightBreakSelect = row.querySelector('select[data-break-type="night"]');

            if (nightBreakSelect) {
                const newNightBreak = nightBreakSelect.value;
                const original = originalBreakTimes[staffName];

                if (original) {
                    // For night shift, we store the break in shortBreakTime and clear secondBreakTime
                    const originalBreak = original.shortBreakTime !== 'N/A' ? original.shortBreakTime : original.secondBreakTime;

                    if (newNightBreak !== originalBreak) {
                        changes[staffName] = {
                            oldShort: original.shortBreakTime,
                            oldSecond: original.secondBreakTime,
                            newShort: newNightBreak, // Store night break as shortBreakTime
                            newSecond: 'N/A' // Clear second break for night shift
                        };
                        hasChanges = true;
                    }
                }
            }
        }
    });

    if (!hasChanges) {
        alert('No changes detected.');
        return;
    }

    // Validate break time conflicts
    if (!validateBreakTimeChanges(changes)) {
        return;
    }

    // Apply the changes
    applyBreakChangesToSchedule(changes);

    // Update UI
    regenerateScheduleStats();
    renderBreakHoursTable();
    alert('Break time changes applied successfully!');
}

function validateBreakTimeChanges(changes) {
    const timeSlotUsage = {};

    // Check for conflicts in the new break times
    Object.keys(changes).forEach(staffName => {
        const change = changes[staffName];

        if (isDayShift) {
            // Day shift: Check both breaks
            [change.newShort, change.newSecond].forEach(time => {
                if (time && time !== 'N/A') {
                    if (!timeSlotUsage[time]) {
                        timeSlotUsage[time] = [];
                    }
                    timeSlotUsage[time].push(staffName);
                }
            });
        } else {
            // Night shift: Only check the single break (stored in newShort)
            if (change.newShort && change.newShort !== 'N/A') {
                if (!timeSlotUsage[change.newShort]) {
                    timeSlotUsage[change.newShort] = [];
                }
                timeSlotUsage[change.newShort].push(staffName);
            }
        }
    });

    // Check for conflicts with unchanged staff
    if (window.originalStaffStats) {
        Object.keys(window.originalStaffStats).forEach(staffName => {
            if (!changes[staffName]) {
                const staff = window.originalStaffStats[staffName];

                if (isDayShift) {
                    // Day shift: Check both break times
                    [staff.shortBreakTime, staff.secondBreakTime].forEach(time => {
                        if (time && time !== 'N/A') {
                            if (!timeSlotUsage[time]) {
                                timeSlotUsage[time] = [];
                            }
                            timeSlotUsage[time].push(staffName);
                        }
                    });
                } else {
                    // Night shift: Check only the assigned break time
                    const nightBreak = staff.shortBreakTime !== 'N/A' ? staff.shortBreakTime : staff.secondBreakTime;
                    if (nightBreak && nightBreak !== 'N/A') {
                        if (!timeSlotUsage[nightBreak]) {
                            timeSlotUsage[nightBreak] = [];
                        }
                        timeSlotUsage[nightBreak].push(staffName);
                    }
                }
            }
        });
    }

    // Report conflicts
    const conflicts = [];
    Object.keys(timeSlotUsage).forEach(time => {
        if (timeSlotUsage[time].length > 1) {
            conflicts.push(`${time}: ${timeSlotUsage[time].join(', ')}`);
        }
    });

    if (conflicts.length > 0) {
        alert(`Break time conflicts detected:\n\n${conflicts.join('\n')}\n\nPlease resolve these conflicts before applying changes.`);
        return false;
    }

    return true;
}

function applyBreakChangesToSchedule(changes) {
    // Update the schedule object
    Object.keys(changes).forEach(staffName => {
        const change = changes[staffName];

        // Remove old break assignments
        Object.keys(window.schedule).forEach(timeSlot => {
            if (window.schedule[timeSlot].staffBreaks && window.schedule[timeSlot].staffBreaks[staffName]) {
                delete window.schedule[timeSlot].staffBreaks[staffName];
            }
        });

        // Add new break assignments
        const staff = window.originalStaffStats[staffName];
        if (staff) {
            // Update staff stats
            staff.shortBreakTime = change.newShort;
            staff.secondBreakTime = change.newSecond;

            // Add to schedule
            if (change.newShort && change.newShort !== 'N/A' && window.schedule[change.newShort]) {
                if (!window.schedule[change.newShort].staffBreaks) {
                    window.schedule[change.newShort].staffBreaks = {};
                }

                if (isDayShift) {
                    window.schedule[change.newShort].staffBreaks[staffName] = "30-MIN BREAK";
                } else {
                    window.schedule[change.newShort].staffBreaks[staffName] = "NIGHT BREAK";
                }
            }

            if (change.newSecond && change.newSecond !== 'N/A' && window.schedule[change.newSecond]) {
                if (!window.schedule[change.newSecond].staffBreaks) {
                    window.schedule[change.newSecond].staffBreaks = {};
                }

                if (isDayShift) {
                    window.schedule[change.newSecond].staffBreaks[staffName] = "2ND BREAK";
                } else {
                    window.schedule[change.newSecond].staffBreaks[staffName] = "NIGHT BREAK";
                }
            }
        }
    });

    // Re-render the main schedule table
    if (window.schedule && window.originalStaffStats) {
        const allStaff = Object.keys(window.originalStaffStats);
        const patients = Object.keys(window.schedule[Object.keys(window.schedule)[0]].patientAssignments || {}).filter(p => p !== 'OBS');
        renderSchedule(window.schedule, allStaff, patients, window.originalStaffStats);
    }
}

function renderBreakHoursTable() {
    if (!window.originalStaffStats) {
        return;
    }

    const breakHoursTable = document.getElementById('breakHoursTable').querySelector('tbody');
    breakHoursTable.innerHTML = '';

    const allStaff = Object.keys(window.originalStaffStats);

    // Filter out nursing staff from break hours table
    const nonNursingStaff = allStaff.filter(s => s !== nurseInCharge1 && s !== nurseInCharge2);

    nonNursingStaff.forEach(s => {
        const row = document.createElement('tr');
        const staffStats = window.originalStaffStats[s];

        // Staff name cell with initials
        const staffCell = document.createElement('td');
        staffCell.textContent = getInitials(s);
        staffCell.title = s; // Add full name as tooltip
        row.appendChild(staffCell);

        if (isDayShift) {
            // Day shift: show both break columns as before
            const shortBreakCell = document.createElement('td');
            shortBreakCell.textContent = staffStats.shortBreakTime || "N/A";
            row.appendChild(shortBreakCell);

            const secondBreakCell = document.createElement('td');
            secondBreakCell.textContent = staffStats.secondBreakTime || "N/A";
            row.appendChild(secondBreakCell);
        } else {
            // Night shift: only show 00:00, 02:00, 04:00 as valid break hours
            // If the staff's break is not one of these, show N/A
            const allowedNightBreaks = ["00:00", "02:00", "04:00"];
            let nightBreak = staffStats.shortBreakTime !== 'N/A' ? staffStats.shortBreakTime : staffStats.secondBreakTime;
            // Convert e.g. "00:00-01:00" to "00:00" for comparison
            if (nightBreak && nightBreak.includes('-')) {
                nightBreak = nightBreak.split('-')[0];
            }
            const showBreak = allowedNightBreaks.includes(nightBreak) ? nightBreak : "N/A";
            const nightBreakCell = document.createElement('td');
            nightBreakCell.textContent = showBreak;
            row.appendChild(nightBreakCell);

            // Second column: always N/A for night shift (to keep table structure)
            const naCell = document.createElement('td');
            naCell.textContent = "N/A";
            row.appendChild(naCell);
        }

        breakHoursTable.appendChild(row);
    });
}

// Add renderStaffRotationStats function if it's missing
function renderStaffRotationStats(patients, staff) {
    // Generate a table showing how many times each staff member has worked with each patient
    let rotationHtml = '<h2>Staff-Patient Rotation History</h2>';
    rotationHtml += '<p>This table shows how many times each staff member has worked with each patient across all schedules.</p>';
    rotationHtml += '<table class="rotation-table">';

    // Header row with patient initials
    rotationHtml += '<tr><th>Staff</th>';
    patients.forEach(patient => {
        rotationHtml += `<th title="${patient}">${getInitials(patient)}</th>`;
    });
    rotationHtml += '</tr>';

    // Rows for each staff member with initials
    staff.forEach(s => {
        rotationHtml += `<tr><td title="${s}">${getInitials(s)} (${s})</td>`;
        patients.forEach(patient => {
            const count = (staffPatientHistory[s] && staffPatientHistory[s][patient]) || 0;
            const colorIntensity = Math.min(count * 20, 100);
            rotationHtml += `<td style="background-color: rgba(0, 123, 255, ${colorIntensity / 100}); color: ${colorIntensity > 50 ? 'white' : 'black'};" title="${s} worked with ${patient} ${count} times">${count}</td>`;
        });
        rotationHtml += '</tr>';
    });

    rotationHtml += '</table>';
    rotationHtml += '<p><em>Note: Lower numbers (lighter cells) indicate staff members who have worked less frequently with those patients.</em></p>';

    const rotationStatsDiv = document.getElementById('rotationStats');
    if (rotationStatsDiv) {
        rotationStatsDiv.innerHTML = rotationHtml;
    }
}
    </script>

<!-- Staff selection popup with overlay -->
<div id="popupOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%;
     background-color: rgba(0,0,0,0.5); z-index:1500;"></div>

<div id="staffPopup" style="display:none; position:fixed; top:30%; left:50%; transform:translate(-50%,-30%);
     background-color: var(--container-bg-color); color: var(--text-color); border:2px solid var(--button-bg-color);
     border-radius:8px; z-index:2000; padding:20px; min-width:300px; box-shadow: 0 4px 20px rgba(0,0,0,0.25);">
    <h3>Select Staff for Assignment</h3>
    <div id="staffList" style="max-height: 300px; overflow-y: auto; margin: 15px 0;"></div>
    <div style="display: flex; justify-content: space-between; margin-top: 15px;">
        <button id="removeAllStaffBtn" style="background-color: #f44336; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer;">Remove All Staff</button>
        <button id="closePopupBtn" style="background-color: #6c757d; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
    </div>
</div>

<!-- Cleaning Duty Assignment Popup -->
<div id="cleaningDutyPopup" style="display:none; position:fixed; top:30%; left:50%; transform:translate(-50%,-30%);
     background-color: var(--container-bg-color); color: var(--text-color); border:2px solid #9c27b0;
     border-radius:8px; z-index:2000; padding:20px; min-width:350px; box-shadow: 0 4px 20px rgba(0,0,0,0.25);">
    <h3>Assign Staff to Cleaning Duty</h3>
    <div id="cleaningDutyTitle" style="background-color: #9c27b0; color: white; padding: 10px; margin: -20px -20px 15px -20px; border-radius: 6px 6px 0 0; font-weight: bold; text-align: center;"></div>
    <div id="cleaningStaffList" style="max-height: 300px; overflow-y: auto; margin: 15px 0;"></div>
    <div style="display: flex; justify-content: space-between; margin-top: 15px;">
        <button id="removeCleaningStaffBtn" style="background-color: #f44336; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer;">Remove Assignment</button>
        <button id="closeCleaningPopupBtn" style="background-color: #6c757d; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
    </div>
</div>
</body>
</html>