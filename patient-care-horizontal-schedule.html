<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patient Care Schedule - Horizontal Layout</title>
    <style>
        /* Core styling for light and dark modes */
        :root {
            --background-color: #f9f9f9; /* Light background */
            --text-color: #333333; /* Dark text color */
            --container-bg-color: #ffffff; /* White container background */
            --button-bg-color: #0077ff; /* Bright blue button color */
            --button-hover-bg-color: #0056cc; /* Darker blue for hover */
            --table-header-bg-color: #f3f4f6; /* Light gray for table headers */
            --table-header-text-color: #333333; /* Dark text for table headers */
            --table-cell-bg-color: #ffffff; /* White table cell background */
            --table-cell-text-color: #333333; /* Dark text color for table cells */
            --break-bg-color: #ffefc1; /* Soft yellow for breaks */
            --lunch-bg-color: #c1f0c1; /* Soft green for lunch */
            --unassigned-bg-color: #ffc1c1; /* Soft red for unassigned */
            --primary-font: 'Poppins', sans-serif; /* Modern font */
        }

        /* Dark mode overrides */
        body.dark-mode {
            --background-color: #1f2937; /* Dark background */
            --text-color: #f9fafb; /* Light text color */
            --container-bg-color: #374151; /* Dark gray container background */
            --button-bg-color: #2563eb; /* Blue button color */
            --button-hover-bg-color: #1d4ed8; /* Darker blue for hover */
            --table-header-bg-color: #4b5563; /* Darker gray for table headers */
            --table-header-text-color: #f9fafb; /* Light text for table headers */
            --table-cell-bg-color: #4b5563; /* Dark gray table cell background */
            --table-cell-text-color: #f9fafb; /* Light text color for table cells */
            --break-bg-color: #fbbf24; /* Yellow for breaks */
            --lunch-bg-color: #22c55e; /* Green for lunch */
            --unassigned-bg-color: #ef4444; /* Red for unassigned */
        }

        /* General body styling */
        body {
            font-family: var(--primary-font);
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.8;
            transition: background-color 0.5s ease, color 0.5s ease;
        }
        h1, h2 {
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-top: 20px;
        }
        h2 {
            font-size: 1.8rem;
        }
        .container {
            width: 100%; /* Ensure it takes full width */
            max-width: 1200px; /* Limit the maximum width */
            min-width: 800px; /* Ensure a minimum width for smaller content */
            margin: 0 auto;
            padding: 30px;
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            overflow-x: auto; /* Allow horizontal scrolling for overflowing content */
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease;
        }
        .setup-section {
            background-color: var(--container-bg-color); /* Use dark mode container background */
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e0e4e8;
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease; /* Smooth transition */
        }
        .setup-section h2 {
            margin-bottom: 10px;
        }
        .staff-inputs, .patient-inputs, .security-staff-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        input, select {
            padding: 8px;
            border: 1px solid #dfe4ea;
            border-radius: 5px;
            width: 150px; /* Shortened width */
            font-size: 14px;
            background-color: #ffffff;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        input:focus, select:focus {
            outline: none;
            border-color: #4a69bd;
            box-shadow: 0 0 5px rgba(74, 105, 189, 0.5);
        }
        button {
            background-color: var(--button-bg-color);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: var(--button-hover-bg-color);
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background-color: var(--table-cell-bg-color);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 15px;
            text-align: center;
            font-size: 14px;
            background-color: var(--table-cell-bg-color);
            color: var(--table-cell-text-color);
            transition: background-color 0.5s ease, color 0.5s ease;
        }
        th {
            background-color: var(--table-header-bg-color);
            color: var(--table-header-text-color);
            font-weight: 600;
        }
        tr:nth-child(even) td {
            background-color: #f9fafb;
            color: var(--table-cell-text-color); /* Explicitly set text color */
        }
        tr:nth-child(odd) td {
            background-color: var(--table-cell-bg-color);
            color: var(--table-cell-text-color); /* Explicitly set text color */
        }
        .row-header {
            background-color: var(--table-header-bg-color);
            color: var(--table-header-text-color);
            font-weight: bold;
            text-align: left;
        }
        .staff-break {
            background-color: var(--break-bg-color);
        }
        .staff-lunch {
            background-color: var(--lunch-bg-color);
        }
        .schedule-container {
            overflow-x: auto;
            margin-top: 20px;
        }
        .stats {
            margin-top: 20px;
            background-color: var(--container-bg-color); /* Use dark mode container background */
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e0e4e8;
            color: var(--text-color); /* Ensure text color adapts to dark mode */
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease; /* Smooth transition */
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 50%;
        }
        .legend-break {
            background-color: var(--break-bg-color);
        }
        .legend-lunch {
            background-color: var(--lunch-bg-color);
        }
        .legend-unassigned {
            background-color: var(--unassigned-bg-color);
        }

        /* Ensure text color is visible for cells with white background in dark mode */
        body.dark-mode td {
            color: var(--text-color); /* Use the light text color defined for dark mode */
        }

        body.dark-mode tr:nth-child(even) td {
            background-color: #374151; /* Dark gray for even rows in dark mode */
            color: var(--table-cell-text-color); /* Ensure text color is visible */
        }

        body.dark-mode tr:nth-child(odd) td {
            background-color: var(--table-cell-bg-color); /* Dark gray for odd rows in dark mode */
            color: var(--table-cell-text-color); /* Ensure text color is visible */
        }

        /* Explicitly set text color for cells with white background */
        body.dark-mode td[style*="background-color: #ffffff"] {
            color: #333333; /* Dark text color for white background */
        }

        .staff-count {
            padding: 5px; /* Reduce padding */
            border: 1px solid #dfe4ea;
            border-radius: 5px;
            width: 80px; /* Adjust width to save space */
            font-size: 12px; /* Reduce font size */
            background-color: #ffffff;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .staff-count:focus {
            outline: none;
            border-color: #4a69bd;
            box-shadow: 0 0 5px rgba(74, 105, 189, 0.5);
        }

        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #f44336;
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Title dynamically updates based on the current shift -->
        <h1 id="siteTitle">Day Shift Allocation</h1>

        <!-- Buttons for toggling shift and dark mode -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <button id="toggleShiftBtn" style="padding: 10px 20px; font-size: 14px;">Switch to Night Shift</button>
            <button id="toggleModeBtn" title="Toggle Dark/Light Mode"></button>
        </div>

        <!-- Replace the Security Staff and Nurse in Charge sections with this flex container -->
        <div class="setup-section" style="margin-bottom: 20px;">
            <div style="display: flex; gap: 40px; align-items: flex-start;">
                <!-- Security Staff Section -->
                <div>
                    <h2>Security Staff</h2>
                    <div class="security-staff-inputs" id="securityStaffInputs"></div>
                    <button id="addSecurityStaffBtn">Add Security Staff</button>
                    <button id="removeSecurityStaffBtn">Remove Security Staff</button>
                </div>
                <!-- Nurse in Charge Section -->
                <div>
                    <h2>Nurse in Charge</h2>
                    <input type="text" id="nurseInChargeInput" placeholder="Enter Nurse in Charge Name" style="width: 250px; margin-bottom: 15px;">
                </div>
            </div>
        </div>

        <!-- Section for managing health care workers and patients -->
        <div class="setup-section">
            <h2>Health Care Worker (HCW)</h2>
            <div class="staff-inputs" id="staffInputs"></div>
            <button id="addStaffBtn">Add Health Care Worker</button>
            <button id="removeStaffBtn">Remove Health Care Worker</button>

            <h2>Patient Names</h2>
            <div class="patient-inputs" id="patientInputs"></div>
            <button id="addPatientBtn">Add Patient</button>
            <button id="removePatientBtn">Remove Patient</button>

            <!-- Buttons for generating and resetting the schedule -->
            <button id="generateBtn">Generate Schedule</button>
            <button id="resetBtn">Reset</button>
            <!-- Debugging Button -->
            <!-- This button is for debugging purposes only. Remove this button and its functionality before final deployment. -->
            <button id="debugFillBtn" style="background-color: #ff5722; color: white; margin-top: 10px;">Debug: Fill Random Names</button>
        </div>

        <!-- Legend for schedule colors -->
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color legend-break"></div>
                <div>30-min Break</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-lunch"></div>
                <div>1-hour Lunch</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-unassigned"></div>
                <div>Unassigned</div>
            </div>
        </div>

        <!-- Schedule tables -->
        <div class="schedule-container">
            <h2>Patient Care Schedule</h2>
            <table id="scheduleTable">
                <thead id="scheduleHeader"></thead>
                <tbody id="scheduleBody"></tbody>
            </table>
        </div>

        <div class="schedule-container">
            <h2>Staff Schedule</h2>
            <table id="staffTable">
                <thead id="staffHeader"></thead>
                <tbody id="staffBody"></tbody>
            </table>
        </div>

        <div class="schedule-container">
            <h2>Staff Break Hours</h2>
            <table id="breakHoursTable">
                <thead>
                    <tr>
                        <th>Staff</th>
                        <th>30-min Break</th>
                        <th>2nd Break</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <!-- Statistics section -->
        <div class="stats" id="stats"></div>
    </div>

    <script>
        // Immediately Invoked Function Expression (IIFE) to avoid global variables
(function() {
    // All your application code goes here
    const PatientCareApp = {
        // Your app object
    };
    
    // Initialize on window load
    window.onload = function() {
        PatientCareApp.init();
    };
})();

        // Global variable to store the schedule
        let schedule = {};

        // Variable to track the current shift (true = Day Shift, false = Night Shift)
        let isDayShift = true;

        // Time slots for day and night shifts
        const dayShiftSlots = [
            "08:00-09:00", "09:00-10:00", "10:00-11:00", "11:00-12:00",
            "12:00-13:00", "13:00-14:00", "14:00-15:00", "15:00-16:00",
            "16:00-17:00", "17:00-18:00", "18:00-19:00", "19:00-20:00"
        ];

        const nightShiftSlots = [
            "20:00-21:00", "21:00-22:00", "22:00-23:00", "23:00-00:00",
            "00:00-01:00", "01:00-02:00", "02:00-03:00", "03:00-04:00",
            "04:00-05:00", "05:00-06:00", "06:00-07:00", "07:00-08:00"
        ];

        // Current time slots (default to day shift)
        let timeSlots = [...dayShiftSlots];

        // Function to update the shift based on the current time or manual toggle
        function updateShift(isManualToggle = false) {
            const currentHour = new Date().getHours(); // Get the current hour (0-23)
            const siteTitle = document.getElementById('siteTitle'); // Site heading
            const toggleShiftBtn = document.getElementById('toggleShiftBtn'); // Toggle button

            // Determine the shift
            if (!isManualToggle) {
                // Automatic shift based on time
                isDayShift = currentHour >= 8 && currentHour < 19;
            } else {
                // Manual toggle
                isDayShift = !isDayShift;
            }

            // Update the time slots and site title
            if (isDayShift) {
                timeSlots = [...dayShiftSlots];
                siteTitle.textContent = "Day Shift Allocation";
                toggleShiftBtn.textContent = "Switch to Night Shift";
            } else {
                timeSlots = [...nightShiftSlots];
                siteTitle.textContent = "Night Shift Allocation";
                toggleShiftBtn.textContent = "Switch to Day Shift";
            }

            // Re-initialize the schedule object
            schedule = {};
            timeSlots.forEach(time => {
                schedule[time] = {
                    patientAssignments: {},
                    staffBreaks: {}
                };
            });

            // Regenerate the schedule header
            updateScheduleHeader();
        }

        // Function to clear all data (staff, patients, and schedules)
        function clearAllData() {
            // Clear staff and patient inputs
            document.getElementById('staffInputs').innerHTML = '';
            document.getElementById('patientInputs').innerHTML = '';
            document.getElementById('securityStaffInputs').innerHTML = '';

            // Clear schedule tables
            document.getElementById('scheduleBody').innerHTML = '';
            document.getElementById('staffBody').innerHTML = '';
            document.getElementById('breakHoursTable').querySelector('tbody').innerHTML = '';

            // Clear statistics
            document.getElementById('stats').innerHTML = '';
        }

        // Function to update the schedule header based on the current time slots
        function updateScheduleHeader() {
            const scheduleHeader = document.getElementById('scheduleHeader');
            let headerHTML = '<tr><th>Patient</th>';
            timeSlots.forEach(time => {
                headerHTML += `<th>${time}</th>`;
            });
            headerHTML += '</tr>';
            scheduleHeader.innerHTML = headerHTML;
        }

        // Function to clear the schedule
        function clearSchedule() {
            document.getElementById('scheduleBody').innerHTML = ''; // Clear patient schedule
            document.getElementById('staffBody').innerHTML = ''; // Clear staff schedule
        }

        // Generate a schedule automatically
        function generateSchedule() {
            const patientInputs = document.querySelectorAll('.patient-container');
            const staffInputs = document.querySelectorAll('.staff-container');
            const securityStaffInputs = document.querySelectorAll('.security-container');

            const staff = [];
            const excludedHours = {};
            const securityStaff = new Set();
            const patients = [];

            // Process security staff
            securityStaffInputs.forEach(container => {
                const staffName = container.querySelector('.security-name').value.trim();

                if (staffName) {
                    staff.push(staffName);
                    securityStaff.add(staffName); // Add to the set of security staff
                }
            });

            // Process other staff
            staffInputs.forEach(container => {
                const staffName = container.querySelector('.staff-name').value.trim();

                if (staffName) {
                    staff.push(staffName);
                    excludedHours[staffName] = 0; // No additional excluded hours for non-security staff
                }
            });

            // Process patients
            patientInputs.forEach(container => {
                const patientName = container.querySelector('.patient-name').value.trim();
                const staffCount = parseInt(container.querySelector('.staff-count').value);

                if (patientName) {
                    patients.push({ name: patientName, staffCount });
                }
            });

            // Log inputs for debugging
            console.log("Staff:", staff);
            console.log("Security Staff:", Array.from(securityStaff));
            console.log("Patients:", patients);

            // Validate inputs
            if (staff.length === 0) {
                alert("Please enter at least one staff name");
                return;
            }

            if (patients.length === 0) {
                alert("Please enter at least one patient name");
                return;
            }

            // Initialize schedule data structure
            schedule = {}; // Reset the schedule object
            timeSlots.forEach(time => {
                schedule[time] = {
                    patientAssignments: {},
                    staffBreaks: {}
                };

                // Initialize each patient to have no staff assigned
                patients.forEach(patient => {
                    schedule[time].patientAssignments[patient.name] = [];
                });

                // Initialize each staff to not be on break
                staff.forEach(s => {
                    schedule[time].staffBreaks[s] = "";
                });
            });

            // Log initialized schedule for debugging
            console.log("Initialized Schedule:", schedule);

            // Track total work and break time for each staff
            const staffStats = {};
            staff.forEach(s => {
                staffStats[s] = {
                    workHours: 0,
                    breakTime: 0,
                    shortBreakTime: "",
                    lunchTime: "",
                    secondBreakTime: ""
                };
            });

            // Assign breaks for each staff member
            staff.forEach((s, index) => {
                let totalBreakTime = 0;

                // Assign 1-hour lunch break
                const lunchStartIndex = timeSlots.findIndex(slot => slot.startsWith("12:00") || slot.startsWith("00:00"));
                const lunchHour = lunchStartIndex + (index % (timeSlots.length - lunchStartIndex)); // Stagger lunch breaks
                const lunchTime = timeSlots[lunchHour];

                schedule[lunchTime].staffBreaks[s] = "1-HOUR LUNCH";
                staffStats[s].lunchTime = lunchTime;
                staffStats[s].breakTime += 1;
                totalBreakTime += 1;

                // Assign 30-minute break
                const breakStartIndex = 1; // Start from second hour
                let breakEndIndex = lunchStartIndex; // Default: before lunch

                // For night shift, exclude the last hour from break allocation
                if (!isDayShift) {
                    breakEndIndex = timeSlots.length - 1; // Exclude last hour
                    // If lunch is before the last hour, still use lunchStartIndex
                    if (lunchStartIndex < breakEndIndex) {
                        breakEndIndex = lunchStartIndex;
                    }
                }

                const breakSlotCount = breakEndIndex - breakStartIndex;
                const shortBreakHour = breakStartIndex + (index % breakSlotCount);
                const shortBreakTime = timeSlots[shortBreakHour];

                schedule[shortBreakTime].staffBreaks[s] = "30-MIN BREAK";
                staffStats[s].shortBreakTime = shortBreakTime;
                staffStats[s].breakTime += 0.5;
                totalBreakTime += 0.5;

                // Assign 2nd break (previously lunch)
                const secondBreakStartIndex = breakEndIndex + 1; // Example logic for 2nd break
                const secondBreakHour = secondBreakStartIndex + (index % (timeSlots.length - secondBreakStartIndex));
                const secondBreakTime = timeSlots[secondBreakHour % timeSlots.length];

                schedule[secondBreakTime].staffBreaks[s] = "2ND BREAK";
                staffStats[s].secondBreakTime = secondBreakTime;
                staffStats[s].breakTime += 1;
                totalBreakTime += 1;

                // Ensure total break time does not exceed 1.5 hours
                if (totalBreakTime > 1.5) {
                    console.warn(`Staff ${s} has exceeded the allowed break time of 1.5 hours.`);
                }
            });

            // Log staff stats after assigning breaks
            console.log("Staff Stats After Break Assignment:", staffStats);

            // Assign staff to patients
            const lastAssigned = {}; // Track the last time a staff member was assigned to a patient

            timeSlots.forEach((time, timeIndex) => {
                const availableStaff = staff.filter(s => {
                    const isOnBreak = schedule[time].staffBreaks[s] !== "";
                    const isSecurity = securityStaff.has(s);

                    // Restrict security staff from 08:00-09:59 (Day Shift) or 19:00-20:59 (Night Shift)
                    const isInRestrictedTime =
                        (isDayShift && timeIndex < 2) || // First 2 hours of Day Shift
                        (!isDayShift && timeIndex < 2); // First 2 hours of Night Shift

                    const hasAdditionalExclusion = timeIndex < excludedHours[s] || timeIndex >= timeSlots.length - excludedHours[s];

                    return !isOnBreak && (!isSecurity || !isInRestrictedTime) && !hasAdditionalExclusion;
                });

                availableStaff.sort((a, b) => staffStats[a].workHours - staffStats[b].workHours);

                patients.forEach(patient => {
                    const assignedStaff = [];

                    for (let i = 0; i < patient.staffCount; i++) {
                        let staffMember = availableStaff.find(s => {
                            // Enforce the rule: staff should not be assigned to the same patient in consecutive hours
                            if (lastAssigned[s] && lastAssigned[s][patient.name] === timeIndex - 1) {
                                return false;
                            }
                            return true;
                        });

                        // If no staff found with the rule, fallback to any available staff
                        if (!staffMember && availableStaff.length > 0) {
                            staffMember = availableStaff[0];
                        }

                        // If still no staff available, fallback to any staff (even if on break or already assigned)
                        if (!staffMember && staff.length > 0) {
                            staffMember = staff[0];
                        }

                        if (staffMember) {
                            assignedStaff.push(staffMember);
                            // Remove from availableStaff only if present
                            const idx = availableStaff.indexOf(staffMember);
                            if (idx !== -1) availableStaff.splice(idx, 1);

                            // Update last assigned time for this staff and patient
                            if (!lastAssigned[staffMember]) {
                                lastAssigned[staffMember] = {};
                            }
                            lastAssigned[staffMember][patient.name] = timeIndex;

                            // Update staff stats
                            staffStats[staffMember].workHours += 1;
                        }
                    }

                    schedule[time].patientAssignments[patient.name] = assignedStaff;
                });
            });

            // Log final schedule and staff stats
            console.log("Final Schedule:", schedule);
            console.log("Final Staff Stats:", staffStats);

            renderSchedule(schedule, staff, patients.map(p => p.name), staffStats);
        }
        
        // Helper function to calculate text color based on background color brightness
        function getContrastColor(hexColor) {
            // Remove the hash if present
            hexColor = hexColor.replace('#', '');

            // Convert hex to RGB
            const r = parseInt(hexColor.substring(0, 2), 16);
            const g = parseInt(hexColor.substring(2, 4), 16);
            const b = parseInt(hexColor.substring(4, 6), 16);

            // Calculate brightness (YIQ formula)
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;

            // Return white for dark backgrounds and black for light backgrounds
            return brightness > 128 ? '#000000' : '#ffffff';
        }

        // Generate a unique color for each staff member
        function generateStaffColors(staff) {
            const colors = {};
            const colorPalette = [
                "#ffadad", "#ffd6a5", "#fdffb6", "#caffbf", "#9bf6ff",
                "#a0c4ff", "#bdb2ff", "#ffc6ff", "#fffffc", "#d0f4de"
            ]; // Add more colors if needed

            staff.forEach((s, index) => {
                const bgColor = colorPalette[index % colorPalette.length]; // Cycle through the palette
                const textColor = getContrastColor(bgColor); // Calculate contrast color
                colors[s] = { bgColor, textColor }; // Store both background and text colors
            });

            return colors;
        }

        // Updated renderSchedule function
        function renderSchedule(schedule, staff, patients, staffStats) {
            // Generate colors for staff
            const staffColors = generateStaffColors(staff);

            // Setup patient schedule header (time slots horizontally)
            const scheduleHeader = document.getElementById('scheduleHeader');
            let headerHTML = '<tr><th>Patient</th>';
            
            timeSlots.forEach(time => {
                const endingHour = time.split('-')[1];
                headerHTML += `<th>${endingHour}</th>`;
            });
            
            headerHTML += '</tr>';
            scheduleHeader.innerHTML = headerHTML;

            // Setup patient schedule body (patient rows)
            const scheduleBody = document.getElementById('scheduleBody');
            scheduleBody.innerHTML = '';
            
            patients.forEach(patient => {
                const row = document.createElement('tr');
                
                // Add patient name cell
                const patientCell = document.createElement('td');
                patientCell.textContent = patient;
                patientCell.className = 'row-header';
                row.appendChild(patientCell);
                
                // Add cells for each time slot
                timeSlots.forEach(time => {
                    const cell = document.createElement('td');
                    const assignedStaff = schedule[time].patientAssignments[patient];
                    
                    if (assignedStaff.length === 0) {
                        cell.textContent = "UNASSIGNED";
                        cell.style.backgroundColor = "#ffeaa7"; // Yellow for unassigned
                        cell.style.color = "#000000"; // Black text for contrast
                    } else {
                        cell.textContent = assignedStaff.join(", ");
                        const { bgColor, textColor } = staffColors[assignedStaff[0]]; // Use the first staff's color
                        cell.style.backgroundColor = bgColor;
                        cell.style.color = textColor; // Set text color for contrast
                    }
                    
                    row.appendChild(cell);
                });
                
                scheduleBody.appendChild(row);
            });

            // Setup staff schedule header (same as patient schedule)
            const staffHeader = document.getElementById('staffHeader');
            staffHeader.innerHTML = headerHTML;

            // Setup staff schedule body (staff rows)
            const staffBody = document.getElementById('staffBody');
            staffBody.innerHTML = '';
            
            staff.forEach(s => {
                const row = document.createElement('tr');
                
                // Add staff name cell
                const staffCell = document.createElement('td');
                staffCell.textContent = s;
                staffCell.className = 'row-header';
                const { bgColor, textColor } = staffColors[s];
                staffCell.style.backgroundColor = bgColor; // Assign staff color
                staffCell.style.color = textColor; // Ensure text is visible
                row.appendChild(staffCell);
                
                // Add cells for each time slot
                timeSlots.forEach(time => {
                    const cell = document.createElement('td');
                    const breakStatus = schedule[time].staffBreaks[s];
                    
                    if (breakStatus === "30-MIN BREAK") {
                        cell.textContent = "BREAK";
                        cell.className = 'staff-break';
                    } else if (breakStatus === "1-HOUR LUNCH") {
                        cell.textContent = "LUNCH";
                        cell.className = 'staff-lunch';
                    } else if (breakStatus === "2ND BREAK") {
                        cell.textContent = "2ND BREAK";
                        cell.className = 'staff-break';
                    } else {
                        let assigned = false;
                        for (const patient in schedule[time].patientAssignments) {
                            if (schedule[time].patientAssignments[patient].includes(s)) {
                                cell.textContent = patient;
                                cell.style.backgroundColor = bgColor; // Assign staff color
                                cell.style.color = textColor; // Ensure text is visible
                                assigned = true;
                                break;
                            }
                        }
                        
                        if (!assigned) {
                            cell.textContent = "-";
                        }
                    }
                    
                    row.appendChild(cell);
                });
                
                staffBody.appendChild(row);
            });

            // Show statistics
            renderStats(staffStats, staff, patients);
            renderBreakHoursTable(staffStats, staff);
        }
        
        // Render statistics
        function renderStats(staffStats, staff, patients) {
            const statsDiv = document.getElementById('stats');
            // Get security staff from localStorage or global variable
            let securityStaff = [];
            try {
                const savedData = JSON.parse(localStorage.getItem('patientCareData'));
                securityStaff = savedData && savedData.securityStaff ? savedData.securityStaff : [];
            } catch (e) {}

            let statsHtml = '<h2>Health Care Worker (HCW) Work Summary</h2>';
            statsHtml += '<table>';
            statsHtml += '<tr><th>HCW</th><th>Work Hours</th><th>Break Time</th><th>30-min Break</th><th>2nd Break</th></tr>';

            staff.forEach(s => {
                const isSecurity = securityStaff.includes(s);
                const rowStyle = isSecurity ? ' style="background-color:#ffe082;font-weight:bold;"' : '';
                statsHtml += `<tr${rowStyle}>
                    <td>${s}${isSecurity ? ' <span style="color:#d84315;">(Security)</span>' : ''}</td>
                    <td>${staffStats[s].workHours} hours</td>
                    <td>${staffStats[s].breakTime} hours</td>
                    <td>${staffStats[s].shortBreakTime}</td>
                    <td>${staffStats[s].secondBreakTime}</td>
                </tr>`;
            });

            statsHtml += '</table>';

            // Add schedule coverage
            statsHtml += '<h2>Schedule Coverage</h2>';
            statsHtml += `<p>Total HCWs: ${staff.length}</p>`;
            statsHtml += `<p>Total Patients: ${patients.length}</p>`;

            // Calculate patient-to-HCW ratio
            const ratio = staff.length / patients.length;
            statsHtml += `<p>HCW-to-Patient Ratio: ${ratio.toFixed(2)}:1</p>`;

            statsDiv.innerHTML = statsHtml;
        }
        
        // Render break hours table
        function renderBreakHoursTable(staffStats, staff) {
            const breakHoursTableBody = document.querySelector('#breakHoursTable tbody');
            breakHoursTableBody.innerHTML = ''; // Clear existing rows

            staff.forEach(s => {
                const row = document.createElement('tr');

                // Staff name
                const staffCell = document.createElement('td');
                staffCell.textContent = s;
                row.appendChild(staffCell);

                // 30-min Break
                const shortBreakCell = document.createElement('td');
                shortBreakCell.textContent = staffStats[s].shortBreakTime || 'N/A';
                row.appendChild(shortBreakCell);

                // 2nd Break
                const secondBreakCell = document.createElement('td');
                secondBreakCell.textContent = staffStats[s].secondBreakTime || 'N/A';
                row.appendChild(secondBreakCell);

                breakHoursTableBody.appendChild(row); // Only inside the loop!
            });
        }
        
        // Helper function to shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // Function to generate random 2-letter names
        // This function is used for debugging purposes to populate input fields with random names.
        function generateRandomName() {
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            return letters.charAt(Math.floor(Math.random() * letters.length)) +
                   letters.charAt(Math.floor(Math.random() * letters.length));
        }

        // Predefined list of actual names for debugging purposes
        const predefinedNames = [
            "John Doe", "Mary Poppins", "Jane Smith", "Robert Brown", 
            "Emily Davis", "Michael Johnson", "Sarah Wilson", "David Lee", 
            "Laura Martinez", "James Anderson", "Sophia Taylor", "Daniel Thomas"
        ];

        // Function to randomly select a name from the predefined list
        function getRandomName() {
            return predefinedNames[Math.floor(Math.random() * predefinedNames.length)];
        }

        // Function to fill all input fields with random names from the predefined list
        // This function is for debugging purposes only. Remove this function before final deployment.
        async function fillRandomNames() {
            // Fetch random names
            const randomNames = await fetchRandomNames(20); // Fetch 20 random names
            if (randomNames.length === 0) {
                alert("Failed to fetch random names. Please check your internet connection.");
                return;
            }

            let nameIndex = 0;

            // Fill security staff input
            const securityStaffInputs = document.querySelectorAll('.security-name');
            securityStaffInputs.forEach(input => {
                if (nameIndex < randomNames.length) {
                    input.value = randomNames[nameIndex++];
                }
            });

            // Fill staff inputs
            const staffInputs = document.querySelectorAll('.staff-name');
            staffInputs.forEach(input => {
                if (nameIndex < randomNames.length) {
                    input.value = randomNames[nameIndex++];
                }
            });

            // Fill patient inputs
            const patientInputs = document.querySelectorAll('.patient-name');
            patientInputs.forEach(input => {
                if (nameIndex < randomNames.length) {
                    input.value = randomNames[nameIndex++];
                }
            });
        }

        // Function to fetch random names from the internet using Random User API
        async function fetchRandomNames(count = 10) {
            try {
                const response = await fetch(`https://randomuser.me/api/?results=${count}&nat=us`);
                const data = await response.json();
                return data.results.map(user => `${user.name.first} ${user.name.last}`);
            } catch (error) {
                console.error("Error fetching random names:", error);
                return []; // Return an empty array if the API call fails
            }
        }

        // Add event listener to the debugging button
        // This event listener is for debugging purposes only. Remove this listener and the button before final deployment.
        document.getElementById('debugFillBtn').addEventListener('click', fillRandomNames);

        // Call the function on page load to set the initial shift
        window.onload = function () {
            loadFromLocalStorage(); // Load saved data from localStorage

            // Initialize the shift and schedule on page load
            updateShift(); // Ensure the schedule object is initialized

            // Add event listener for the toggle button
            document.getElementById('toggleShiftBtn').addEventListener('click', () => {
                updateShift(true); // Manual toggle
                saveToLocalStorage(); // Save changes to localStorage
            });

            // Add other event listeners here
            document.getElementById('generateBtn').addEventListener('click', generateSchedule);
            document.getElementById('resetBtn').addEventListener('click', () => {
                // Clear all data
                clearAllData();

                // Clear localStorage
                localStorage.removeItem('patientCareData');
                console.log("Data cleared from localStorage");

                // Optionally, reset the shift to the default (e.g., Day Shift)
                isDayShift = true;
                timeSlots = [...dayShiftSlots];
                document.getElementById('siteTitle').textContent = "Day Shift Allocation";
                document.getElementById('toggleShiftBtn').textContent = "Switch to Night Shift";

                // Regenerate the schedule header
                updateScheduleHeader();
            });

            document.getElementById('addSecurityStaffBtn').addEventListener('click', () => {
                const securityStaffInputs = document.getElementById('securityStaffInputs');

                // Check if a security staff input already exists
                if (securityStaffInputs.children.length > 0) {
                    alert("Only one security staff can be added.");
                    return;
                }

                const securityContainer = document.createElement('div');
                securityContainer.className = 'security-container';

                const newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.placeholder = `Security Staff`;
                newInput.className = 'security-name';

                securityContainer.appendChild(newInput);
                securityStaffInputs.appendChild(securityContainer);
            });

            document.getElementById('removeSecurityStaffBtn').addEventListener('click', () => {
                const securityStaffInputs = document.getElementById('securityStaffInputs');
                if (securityStaffInputs.children.length > 0) {
                    securityStaffInputs.removeChild(securityStaffInputs.lastElementChild);
                    saveToLocalStorage(); // Save changes
                }
            });

            document.getElementById('addStaffBtn').addEventListener('click', () => {
                const staffInputs = document.getElementById('staffInputs');
                const staffContainer = document.createElement('div');
                staffContainer.className = 'staff-container';

                const newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.placeholder = `Health Care Worker ${staffInputs.children.length + 1}`;
                newInput.className = 'staff-name';

                staffContainer.appendChild(newInput);
                staffInputs.appendChild(staffContainer);

                saveToLocalStorage(); // Save changes
            });

            document.getElementById('removeStaffBtn').addEventListener('click', () => {
                const staffInputs = document.getElementById('staffInputs');
                if (staffInputs.children.length > 0) {
                    staffInputs.removeChild(staffInputs.lastElementChild);
                    saveToLocalStorage(); // Save changes
                }
            });

            document.getElementById('addPatientBtn').addEventListener('click', () => {
                const patientInputs = document.getElementById('patientInputs');
                const patientContainer = document.createElement('div');
                patientContainer.className = 'patient-container';

                // Create a wrapper for the input and dropdown
                const inputWrapper = document.createElement('div');
                inputWrapper.style.display = 'flex';
                inputWrapper.style.alignItems = 'center';
                inputWrapper.style.gap = '10px'; // Add spacing between input and dropdown

                // Create input for patient name
                const newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.placeholder = `Patient ${patientInputs.children.length + 1}`;
                newInput.className = 'patient-name';

                // Create dropdown for staff level
                const staffCountSelect = document.createElement('select');
                staffCountSelect.className = 'staff-count';

                const option1 = document.createElement('option');
                option1.value = 1;
                option1.textContent = '1:1'; // Simplified label
                option1.selected = true; // Default to Level 1:1

                const option2 = document.createElement('option');
                option2.value = 2;
                option2.textContent = '2:1'; // Simplified label

                const option3 = document.createElement('option');
                option3.value = 3;
                option3.textContent = '3:1'; // Simplified label

                staffCountSelect.appendChild(option1);
                staffCountSelect.appendChild(option2);
                staffCountSelect.appendChild(option3);

                // Append input and dropdown to the wrapper
                inputWrapper.appendChild(newInput);
                inputWrapper.appendChild(staffCountSelect);

                // Append the wrapper to the patient container
                patientContainer.appendChild(inputWrapper);

                // Append the patient container to the patient inputs section
                patientInputs.appendChild(patientContainer);

                saveToLocalStorage(); // Save changes
            });

            document.getElementById('removePatientBtn').addEventListener('click', () => {
                const patientInputs = document.getElementById('patientInputs');
                if (patientInputs.children.length > 0) {
                    patientInputs.removeChild(patientInputs.lastElementChild);
                    saveToLocalStorage(); // Save changes
                }
            });

            // Reset button functionality
            document.getElementById('resetBtn').addEventListener('click', () => {
                // Clear all data
                clearAllData();

                // Optionally, reset the shift to the default (e.g., Day Shift)
                isDayShift = true;
                timeSlots = [...dayShiftSlots];
                document.getElementById('siteTitle').textContent = "Day Shift Allocation";
                document.getElementById('toggleShiftBtn').textContent = "Switch to Night Shift";

                // Regenerate the schedule header
                updateScheduleHeader();

                saveToLocalStorage(); // Save changes
            });

            document.getElementById('toggleModeBtn').addEventListener('click', () => {
                const body = document.body;
                const toggleButton = document.getElementById('toggleModeBtn');

                // Toggle the dark-mode class on the body
                body.classList.toggle('dark-mode');

                // Update the button symbol based on the current mode
                if (body.classList.contains('dark-mode')) {
                    toggleButton.textContent = 'â˜€ï¸'; // Light mode symbol
                } else {
                    toggleButton.textContent = 'ðŸŒ™'; // Dark mode symbol
                }

                saveToLocalStorage(); // Save changes to localStorage
            });

            // Set the initial symbol for the dark mode toggle button
            document.getElementById('toggleModeBtn').textContent = 'ðŸŒ™'; // Default to dark mode symbol

            // Load data from localStorage
            loadFromLocalStorage();
        };

        function saveToLocalStorage() {
            const staffInputs = Array.from(document.querySelectorAll('.staff-name')).map(input => input.value.trim());
            const patientInputs = Array.from(document.querySelectorAll('.patient-container')).map(container => {
                return {
                    name: container.querySelector('.patient-name').value.trim(),
                    staffCount: container.querySelector('.staff-count').value
                };
            });
            const securityStaffInputs = Array.from(document.querySelectorAll('.security-name')).map(input => input.value.trim());
            const nurseInCharge = document.getElementById('nurseInChargeInput').value.trim();

            const data = {
                staff: staffInputs,
                patients: patientInputs,
                securityStaff: securityStaffInputs,
                nurseInCharge, // Save nurse in charge
                schedule,
                isDayShift,
                isDarkMode: document.body.classList.contains('dark-mode')
            };

            localStorage.setItem('patientCareData', JSON.stringify(data));
            console.log("Data saved to localStorage:", data);
        }

        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('patientCareData');
            if (!savedData) return;

            const { staff, patients, securityStaff, nurseInCharge, schedule: savedSchedule, isDayShift: savedShift, isDarkMode } = JSON.parse(savedData);

            // Restore nurse in charge
            document.getElementById('nurseInChargeInput').value = nurseInCharge || "";

            // Restore other data (staff, patients, security staff, schedule, and shift)
            // Existing code for restoring staff, patients, and security staff...
            schedule = savedSchedule;
            isDayShift = savedShift;
            timeSlots = isDayShift ? [...dayShiftSlots] : [...nightShiftSlots];
            document.getElementById('siteTitle').textContent = isDayShift ? "Day Shift Allocation" : "Night Shift Allocation";
            document.getElementById('toggleShiftBtn').textContent = isDayShift ? "Switch to Night Shift" : "Switch to Day Shift";

            console.log("Data loaded from localStorage:", { staff, patients, securityStaff, nurseInCharge, schedule, isDayShift, isDarkMode });
        }

        // Add this helper function to keep code DRY
function getInputValues(selector) {
  return Array.from(document.querySelectorAll(selector)).map(input => input.value.trim());
}

// Replace repetitive DOM selection code with this helper function
function getElement(id) {
  return document.getElementById(id);
}

function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}

const debouncedSave = debounce(saveToLocalStorage, 300);

// Use this for input event handlers
document.querySelectorAll('input, select').forEach(input =>
  input.addEventListener('input', debouncedSave)
);

try {
    // Risky code like localStorage operations
} catch (error) {
    console.error("Error:", error);
    // Show user-friendly message
    showError("Something went wrong. Please try again.");
}

function showError(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.textContent = message;
    document.body.appendChild(errorDiv);
    setTimeout(() => errorDiv.remove(), 5000);
}
    </script>
</body>
</html>