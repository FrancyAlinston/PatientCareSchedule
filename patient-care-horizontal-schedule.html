<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patient Care Schedule - Horizontal Layout</title>
    <style>
        /* Core styling for light and dark modes */
        :root {
            --background-color: #f9f9f9; /* Light background */
            --text-color: #333333; /* Dark text color */
            --container-bg-color: #ffffff; /* White container background */
            --button-bg-color: #0077ff; /* Bright blue button color */
            --button-hover-bg-color: #0056cc; /* Darker blue for hover */
            --table-header-bg-color: #f3f4f6; /* Light gray for table headers */
            --table-header-text-color: #333333; /* Dark text for table headers */
            --table-cell-bg-color: #ffffff; /* White table cell background */
            --table-cell-text-color: #333333; /* Dark text color for table cells */
            --break-bg-color: #ffefc1; /* Soft yellow for breaks */
            --lunch-bg-color: #c1f0c1; /* Soft green for lunch */
            --unassigned-bg-color: #ffc1c1; /* Soft red for unassigned */
            --primary-font: 'Poppins', sans-serif; /* Modern font */
        }

        /* Dark mode overrides */
        body.dark-mode {
            --background-color: #1f2937; /* Dark background */
            --text-color: #f9fafb; /* Light text color */
            --container-bg-color: #374151; /* Dark gray container background */
            --button-bg-color: #2563eb; /* Blue button color */
            --button-hover-bg-color: #1d4ed8; /* Darker blue for hover */
            --table-header-bg-color: #4b5563; /* Darker gray for table headers */
            --table-header-text-color: #f9fafb; /* Light text for table headers */
            --table-cell-bg-color: #4b5563; /* Dark gray table cell background */
            --table-cell-text-color: #f9fafb; /* Light text color for table cells */
            --break-bg-color: #fbbf24; /* Yellow for breaks */
            --lunch-bg-color: #22c55e; /* Green for lunch */
            --unassigned-bg-color: #ef4444; /* Red for unassigned */
        }

        /* General body styling */
        body {
            font-family: var(--primary-font);
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.8;
            transition: background-color 0.5s ease, color 0.5s ease;
        }
        h1, h2 {
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-top: 20px;
        }
        h2 {
            font-size: 1.8rem;
        }
        .container {
            width: 100%; /* Ensure it takes full width */
            max-width: 1200px; /* Limit the maximum width */
            min-width: 800px; /* Ensure a minimum width for smaller content */
            margin: 0 auto;
            padding: 30px;
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            overflow-x: auto; /* Allow horizontal scrolling for overflowing content */
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease;
        }
        .setup-section {
            background-color: var(--container-bg-color); /* Use dark mode container background */
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e0e4e8;
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease; /* Smooth transition */
        }
        .setup-section h2 {
            margin-bottom: 10px;
        }
        .staff-inputs, .patient-inputs, .security-staff-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
           
        }
        input, select {
            padding: 8px;
            border: 1px solid #dfe4ea;
            border-radius: 5px;
            width: 150px; /* Shortened width */
            font-size: 14px;
            background-color: #ffffff;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        input:focus, select:focus, button:focus {
            outline: 3px solid #4a69bd;
            box-shadow: 0 0 5px rgba(74, 105, 189, 0.5);
        }
        button {
            background-color: var(--button-bg-color);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: var(--button-hover-bg-color);
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background-color: var(--table-cell-bg-color);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 15px;
            text-align: center;
            font-size: 14px;
            background-color: var(--table-cell-bg-color);
            color: var(--table-cell-text-color);
            transition: background-color 0.5s ease, color 0.5s ease;
        }
        th {
            background-color: var(--table-header-bg-color);
            color: var(--table-header-text-color);
            font-weight: 600;
        }
        tr:nth-child(even) td {
            background-color: #f9fafb;
            color: var(--table-cell-text-color); /* Explicitly set text color */
        }
        tr:nth-child(odd) td {
            background-color: var(--table-cell-bg-color);
            color: var(--table-cell-text-color); /* Explicitly set text color */
        }
        .row-header {
            background-color: var(--table-header-bg-color);
            color: var(--table-header-text-color);
            font-weight: bold;
            text-align: left;
        }
        .staff-break {
            background-color: var(--break-bg-color);
            color: #000000; /* Ensure black text for contrast with yellow background */
            font-weight: bold;
        }
        .staff-lunch {
            background-color: var(--lunch-bg-color);
            color: #000000; /* Ensure black text for contrast with green background */
            font-weight: bold;
        }
        .schedule-container {
            overflow-x: auto;
            margin-top: 20px;
        }
        .stats {
            margin-top: 20px;
            background-color: var(--container-bg-color); /* Use dark mode container background */
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e0e4e8;
            color: var(--text-color); /* Ensure text color adapts to dark mode */
            transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease; /* Smooth transition */
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 50%;
        }
        .legend-break {
            background-color: var(--break-bg-color);
        }
        .legend-lunch {
            background-color: var(--lunch-bg-color);
        }
        .legend-unassigned {
            background-color: var(--unassigned-bg-color);
        }
        .legend-security {
            background-color: #ffccbc;
        }
        .legend-night-break {
            background-color: #673ab7;
        }
        .staff-cleaning-duty {
            background-color: #9c27b0; /* Purple color for cleaning duties */
            color: #ffffff; /* White text for contrast */
            font-weight: bold;
        }

        .legend-cleaning-duty {
            background-color: #9c27b0;
        }

        /* Ensure text color is visible for cells with white background in dark mode */
        body.dark-mode td {
            color: var(--text-color); /* Use the light text color defined for dark mode */
        }

        body.dark-mode tr:nth-child(even) td {
            background-color: #374151; /* Dark gray for even rows in dark mode */
            color: var(--table-cell-text-color); /* Ensure text color is visible */
        }

        body.dark-mode tr:nth-child(odd) td {
            background-color: var(--table-cell-bg-color); /* Dark gray for odd rows in dark mode */
            color: var(--table-cell-text-color); /* Ensure text color is visible */
        }

        /* Explicitly set text color for cells with white background */
        body.dark-mode td[style*="background-color: #ffffff"] {
            color: #333333; /* Dark text color for white background */
        }

        .staff-count {
            padding: 5px; /* Reduce padding */
            border: 1px solid #dfe4ea;
            border-radius: 5px;
            width: 80px; /* Adjust width to save space */
            font-size: 12px; /* Reduce font size */
            background-color: #ffffff;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .staff-count:focus {
            outline: none;
            border-color: #4a69bd;
            box-shadow: 0 0 5px rgba(74, 105, 189, 0.5);
        }

        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #f44336;
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 1000;
        }

        /* Explicitly set text color for cells when in dark mode */
        body.dark-mode .staff-break {
            background-color: var(--break-bg-color); /* Your dark mode yellow */
            color: #000000; /* Keep black text which contrasts with yellow */
        }

        body.dark-mode .staff-lunch {
            background-color: var(--lunch-bg-color); /* Your dark mode green */
            color: #000000; /* Keep black text which contrasts with green */
        }

        /* Other cells with custom colors in dark mode may need adjustments */
        body.dark-mode td.row-header {
            color: var(--table-header-text-color);
        }

        .rotation-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .rotation-table th, .rotation-table td {
            border: 1px solid #e5e7eb;
            padding: 15px;
            text-align: center;
            font-size: 14px;
        }

        .rotation-table th {
            background-color: var(--table-header-bg-color);
            color: var(--table-header-text-color);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Title dynamically updates based on the current shift -->
        <h1 id="siteTitle">Day Shift Allocation</h1>

        <!-- Buttons for toggling shift and dark mode -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <button id="toggleShiftBtn" style="padding: 10px 20px; font-size: 14px;">Switch to Night Shift</button>
            <button id="toggleModeBtn" title="Toggle Dark/Light Mode"></button>
        </div>

        <!-- Replace the Security Staff and Nurse in Charge sections with this flex container -->
        <div class="setup-section" style="margin-bottom: 20px;">
            <div style="display: flex; gap: 40px; align-items: flex-start;">
                <!-- Security Staff Section -->
                <div>
                    <h2>Security Staff</h2>
                    <div class="security-staff-inputs" id="securityStaffInputs"></div>
                    <button id="addSecurityStaffBtn">Add Security Staff</button>
                    <button id="removeSecurityStaffBtn">Remove Security Staff</button>
                </div>
                
                <!-- Combined Nurses Section -->
                <div>
                    <h2>Nursing Staff</h2>
                    <div style="margin-bottom: 15px;">
                        <label for="nurseInChargeInput"><strong>Nurse in Charge 1:</strong></label>
                        <input type="text" id="nurseInChargeInput" placeholder="Enter First Nurse in Charge" style="width: 250px; margin-bottom: 15px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label for="nurseInCharge2Input"><strong>Nurse in Charge 2:</strong></label>
                        <input type="text" id="nurseInCharge2Input" placeholder="Enter Second Nurse in Charge" style="width: 250px; margin-bottom: 15px;">
                    </div>
                </div>
            </div>
        </div>

        <!-- Add this new section for Health Care Workers only -->
<div class="setup-section" style="margin-bottom: 20px;">
    <h2>Health Care Workers</h2>
    <div class="staff-inputs" id="staffInputs"></div>
    <button id="addStaffBtn">Add Health Care Worker</button>
    <button id="removeStaffBtn">Remove Health Care Worker</button>
</div>

        <!-- Section for managing health care workers and patients -->
        <div class="setup-section">
            <h2>Patient Names</h2>
            <div class="patient-inputs" id="patientInputs"></div>
            <button id="addPatientBtn">Add Patient</button>
            <button id="removePatientBtn">Remove Patient</button>

            <!-- Buttons for generating and resetting the schedule -->
            <button id="generateBtn">Generate Schedule</button>
            <button id="resetBtn">Reset</button>
            <!-- Debugging Button -->
            <!-- This button is for debugging purposes only. Remove this button and its functionality before final deployment. -->
            <button id="debugFillBtn" style="background-color: #ff5722; color: white; margin-top: 10px;">Debug: Fill Random Names</button>
        </div>

        <!-- Legend for schedule colors -->
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color legend-break"></div>
                <div>30-min Break</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-lunch"></div>
                <div>1-hour 2nd Break</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-unassigned"></div>
                <div>Unassigned</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-security"></div>
                <div>Security Duty</div>
            </div>
        </div>

        <!-- Schedule tables -->
        <div class="schedule-container">
            <h2>Patient Care Schedule</h2>
            <table id="scheduleTable">
                <thead id="scheduleHeader"></thead>
                <tbody id="scheduleBody"></tbody>
            </table>
        </div>

        <div class="schedule-container">
            <h2>Staff Schedule</h2>
            <table id="staffTable">
                <thead id="staffHeader"></thead>
                <tbody id="staffBody"></tbody>
            </table>
        </div>

        <div class="schedule-container">
            <h2>Staff Break Hours</h2>
            <table id="breakHoursTable">
                <thead>
                    <tr>
                        <th>Staff</th>
                        <th>30-min Break</th>
                        <th>1-hour 2nd Break</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <!-- Statistics section -->
        <div class="stats" id="stats"></div>

        <!-- Staff-Patient Rotation section -->
        <div class="stats" id="rotationStats"></div>

        <button id="resetRotationBtn" class="action-button">Reset Rotation History</button>
    </div>

    <div id="debugPanel" style="display: none; position: fixed; bottom: 0; right: 0; width: 400px; height: 300px; background-color: rgba(0,0,0,0.8); color: white; padding: 10px; overflow: auto; z-index: 1000; font-family: monospace; font-size: 12px;">
    <h3 style="margin-top: 0; border-bottom: 1px solid white;">Debug Console</h3>
    <button id="clearDebugBtn" style="position: absolute; top: 10px; right: 10px; background-color: #f44336; color: white; border: none; border-radius: 4px; padding: 5px;">Clear</button>
    <div id="debugOutput"></div>
</div>

<button id="toggleDebugBtn" style="position: fixed; bottom: 10px; right: 10px; background-color: #333; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer; z-index: 999;">🐞</button>

    <script>
        // Global variables
        let schedule = {};
        let isDayShift = true;
        let securityStaff = []; // Add this new global variable
        let staffPatientHistory = {};
        const cleaningDuties = [
            "DINING ROOM", "OFFICE ROOM", "TAKE OUT BINS", "LAUNDRY ROOM", "PHONE ROOM",
            "LOUNGE", "KITCHEN", "QUIET ROOM", "CORRIDOR", "TOILETS"
        ];

        // Time slots for day and night shifts
        const dayShiftSlots = [
            "08:00-09:00", "09:00-10:00", "10:00-11:00", "11:00-12:00",
            "12:00-13:00", "13:00-14:00", "14:00-15:00", "15:00-16:00",
            "16:00-17:00", "17:00-18:00", "18:00-19:00", "19:00-20:00"
        ];

        const nightShiftSlots = [
            "20:00-21:00", "21:00-22:00", "22:00-23:00", "23:00-00:00",
            "00:00-01:00", "01:00-02:00", "02:00-03:00", "03:00-04:00",
            "04:00-05:00", "05:00-06:00", "06:00-07:00", "07:00-08:00"
        ];
        
        // Current time slots (default to day shift)
        let timeSlots = [...dayShiftSlots];
        
        // Helper functions
        function getInputValues(selector) {
            return Array.from(document.querySelectorAll(selector)).map(input => input.value.trim());
        }
        
        function getElement(id) {
            return document.getElementById(id);
        }
        
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            }
        }
        
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        // Function to generate random colors for staff
        function generateStaffColors(staff) {
            const staffColors = {};
            const hueStep = 360 / staff.length;
            
            staff.forEach((s, index) => {
                const hue = index * hueStep;
                // Start with standard saturation and lightness
                let saturation = 70;
                let lightness = 80;
                
                // Calculate background color
                const bgColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                
                // Determine text color with guaranteed contrast ratio
                // Use black for light backgrounds, white for dark ones
                // Web standard for ensuring contrast is to use relative luminance:
                const relativeLuminance = calculateRelativeLuminance(hue, saturation, lightness);
                
                // Text color: white for dark backgrounds (smaller luminance), black for light ones
                // The threshold 0.5 is roughly where we need to switch to maintain 4.5:1 contrast
                const textColor = relativeLuminance > 0.5 ? '#000000' : '#ffffff';
                
                staffColors[s] = { bgColor, textColor };
            });
            
            return staffColors;
        }

        // Calculate relative luminance using HSL approximation
        function calculateRelativeLuminance(h, s, l) {
            // This is a simplified model - full implementation would convert HSL to RGB first
            // then apply the proper luminance formula, but this approximation works for this case
            // Adjust perceived brightness based on hue (yellows appear brighter, blues darker)
            const hueFactor = Math.cos((h - 60) * Math.PI / 180) * 0.1;
            
            // Saturation reduces luminance
            const saturationImpact = (s / 100) * 0.3;
            
            // Calculate adjusted luminance
            const adjustedLuminance = (l / 100) - saturationImpact + hueFactor;
            
            return Math.max(0, Math.min(1, adjustedLuminance));
        }

        // 1. Fix validateStaffRequirements to only check security staff
function validateStaffRequirements() {
    const securityCount = document.querySelectorAll('.security-container').length;
    
    if (securityCount > 1) {
        showError(`You can have at most 1 security staff. You currently have ${securityCount}.`);
        return false;
    }
    
    return true;
}

// 2. Fix generateSchedule to handle nurse in charge properly
function generateSchedule() {
    try {
        const patientInputs = document.querySelectorAll('.patient-container');
        const staffInputs = document.querySelectorAll('.staff-container');
        const securityStaffInputs = document.querySelectorAll('.security-container');

        const staff = [];
        const nurses = [];
        const excludedHours = {};
        const patients = [];

        // Process security staff
        securityStaffInputs.forEach(container => {
            const staffName = container.querySelector('.security-name').value.trim();

            if (staffName) {
                staff.push(staffName);
                // Instead of using a Set, add to the global array
                if (!securityStaff.includes(staffName)) {
                    securityStaff.push(staffName);
                }
            }
        });
        
        // Process nurse in charge inputs only
        const nurseInCharge1 = document.getElementById('nurseInChargeInput').value.trim();
        if (nurseInCharge1) {
            staff.push(nurseInCharge1);
            nurses.push(nurseInCharge1);
        }

        const nurseInCharge2 = document.getElementById('nurseInCharge2Input').value.trim();
        if (nurseInCharge2) {
            staff.push(nurseInCharge2);
            nurses.push(nurseInCharge2);
        }

        // Process other staff
        staffInputs.forEach(container => {
            const staffName = container.querySelector('.staff-name').value.trim();

            if (staffName) {
                staff.push(staffName);
            }
        });

        // Validate security staff limit
        if (securityStaffInputs.length > 1) {
            showError("Maximum of 1 security staff allowed");
            return;
        }

        // Process patients
        patientInputs.forEach(container => {
            const patientName = container.querySelector('.patient-name').value.trim();
            const staffCount = parseInt(container.querySelector('.staff-count').value);

            if (patientName) {
                patients.push({ name: patientName, staffCount });
            }
        });

        // Validate inputs
        if (staff.length === 0) {
            alert("Please enter at least one staff name");
            return;
        }

        if (patients.length === 0) {
            alert("Please enter at least one patient name");
            return;
        }

        // Initialize schedule data structure
        schedule = {}; // Reset the schedule object
        timeSlots.forEach(time => {
            schedule[time] = {
                patientAssignments: {},
                staffBreaks: {}
            };

            // Initialize each patient to have no staff assigned
            patients.forEach(patient => {
                schedule[time].patientAssignments[patient.name] = [];
            });

            // Initialize each staff to not be on break
            staff.forEach(s => {
                schedule[time].staffBreaks[s] = "";
            });
        });

        // Initialize staffStats for all staff members
        const staffStats = {};
        staff.forEach(s => {
            staffStats[s] = {
                workHours: 0,
                breakTime: 0,
                shortBreakTime: "",
                secondBreakTime: ""
            };
        });

        // Keep track of the last time a staff was assigned to a patient to avoid consecutive hours
        const lastAssigned = {};

        // Add work hour tracking
        const staffWorkHours = {};
        staff.forEach(s => {
            staffWorkHours[s] = 0;
        });
        
        // Add a map to track consecutive work hours
        const consecutiveWorkHours = {};
        staff.forEach(s => { consecutiveWorkHours[s] = 0; });

        // Initialize staffPatientHistory if it doesn't exist
        if (!staffPatientHistory) {
            staffPatientHistory = {};
        }

        // Initialize history for each staff member
        staff.forEach(s => {
            if (!staffPatientHistory[s]) {
                staffPatientHistory[s] = {};
            }
            
            // Initialize counter for each patient
            patients.forEach(patient => {
                if (!staffPatientHistory[s][patient.name]) {
                    staffPatientHistory[s][patient.name] = 0;
                }
            });
        });

        timeSlots.forEach((time, timeIndex) => {
            // Reset consecutive hours at start of new 4-hour block
            if (timeIndex % 4 === 0) {
                staff.forEach(s => { consecutiveWorkHours[s] = 0; });
            }
            
            // Make a copy of staff for this time slot, excluding security staff during restricted hours
            let availableStaff = [...staff].filter(s => {
                // If this is security staff and it's a restricted hour, exclude them
                if (securityStaff.includes(s) && isSecurityRestrictedHour(timeIndex, timeSlots.length)) {
                    return false;
                }
                return true;
            });
            
            // Create a priority queue of patients based on care requirements
            const sortedPatients = [...patients].sort((a, b) => b.staffCount - a.staffCount);
            
            // Process patients in order of highest care needs first
            sortedPatients.forEach(patient => {
                const assignedStaff = [];
                
                // Create a priority list of staff for this patient
                // Staff who have worked less with this patient get higher priority
                const prioritizedStaff = [...availableStaff].sort((a, b) => {
                    // Primary sort: staff who worked less with this patient get priority
                    if (staffPatientHistory[a][patient.name] !== staffPatientHistory[b][patient.name]) {
                        return staffPatientHistory[a][patient.name] - staffPatientHistory[b][patient.name];
                    }
                    
                    // Secondary sort: avoid consecutive assignments to same patient
                    const aConsecutive = lastAssigned[a] && lastAssigned[a][patient.name] === timeIndex - 1;
                    const bConsecutive = lastAssigned[b] && lastAssigned[b][patient.name] === timeIndex - 1;
                    if (aConsecutive !== bConsecutive) return aConsecutive ? 1 : -1;
                    
                    // Tertiary sort: total work hours for this shift
                    return staffWorkHours[a] - staffWorkHours[b];
                });
                
                // Assign staff to this patient
                for (let i = 0; i < patient.staffCount && prioritizedStaff.length > 0; i++) {
                    const staffMember = prioritizedStaff.shift(); // Take the highest priority staff
                    
                    assignedStaff.push(staffMember);
                    availableStaff = availableStaff.filter(s => s !== staffMember);
                    
                    // Update work hours and consecutive work tracking
                    staffWorkHours[staffMember]++;
                    consecutiveWorkHours[staffMember]++;
                    
                    // Update last assigned time for this staff/patient
                    if (!lastAssigned[staffMember]) {
                        lastAssigned[staffMember] = {};
                    }
                    lastAssigned[staffMember][patient.name] = timeIndex;
                    
                    // Update history counter for this staff/patient pair
                    staffPatientHistory[staffMember][patient.name]++;
                }
                
                schedule[time].patientAssignments[patient.name] = assignedStaff;
            });

            // After assignments, update consecutive work hours
            staff.forEach(s => {
                let isWorking = false;
                
                // Check if staff is assigned to any patient this hour
                for (const patient in schedule[time].patientAssignments) {
                    if (schedule[time].patientAssignments[patient].includes(s)) {
                        isWorking = true;
                        break;
                    }
                }
                
                // Update consecutive hours
                if (isWorking) {
                    consecutiveWorkHours[s]++;
                    
                    // Force a break if more than 3 consecutive hours
                    if (consecutiveWorkHours[s] >= 3 && timeIndex < timeSlots.length - 1) {
                        const nextHour = timeSlots[timeIndex + 1];
                        // Only if they don't already have a break planned
                        if (schedule[nextHour] && !schedule[nextHour].staffBreaks[s]) {
                            schedule[nextHour].staffBreaks[s] = "30-MIN BREAK";
                            staffStats[s].shortBreakTime = nextHour;
                            staffStats[s].breakTime += 0.5;
                            consecutiveWorkHours[s] = 0;
                        }
                    }
                } else if (schedule[time].staffBreaks[s]) {
                    // Reset consecutive work hours after a break
                    consecutiveWorkHours[s] = 0;
                }
            });
        });

        // Assign breaks for each staff
        staff.forEach((s, index) => {
            const shiftLength = timeSlots.length; // 12 hours
            const midPoint = Math.floor(shiftLength / 2);
            
            // Clear any previously assigned breaks for this staff
            timeSlots.forEach(time => {
                schedule[time].staffBreaks[s] = "";
            });

            // Reset break time in stats
            staffStats[s].breakTime = 0;
            staffStats[s].shortBreakTime = "";
            staffStats[s].secondBreakTime = "";
            
            if (isDayShift) {
                // DAY SHIFT: 30-minute break + 1-hour second break
                // 30-minute break - in first half of shift, staggered
                const shortBreakOffset = index % 2; // Stagger by staff index (only 2 nurses)
                const shortBreakHour = Math.min(2 + shortBreakOffset, 5);
                const shortBreakTime = timeSlots[shortBreakHour];
                
                // Assign 30-min break
                schedule[shortBreakTime].staffBreaks[s] = "30-MIN BREAK";
                staffStats[s].shortBreakTime = shortBreakTime;
                staffStats[s].breakTime = 0.5;
                
                // 1-hour second break - in second half of shift, staggered
                const secondBreakOffset = index % 2;
                let secondBreakHour = midPoint + 1 + secondBreakOffset;
                
                // Ensure second break is at least 2 hours after the short break
                if (secondBreakHour - shortBreakHour < 2) {
                    secondBreakHour = shortBreakHour + 2;
                }
                
                // Make sure second break isn't in the last hour
                secondBreakHour = Math.min(secondBreakHour, shiftLength - 2);
                
                const secondBreakTime = timeSlots[secondBreakHour];
                
                // Assign second break
                if (secondBreakTime !== shortBreakTime) {
                    schedule[secondBreakTime].staffBreaks[s] = "2ND BREAK";
                    staffStats[s].secondBreakTime = secondBreakTime;
                    staffStats[s].breakTime += 1.0;
                } else {
                    // Find alternative time if needed
                    const altBreakHour = Math.min(secondBreakHour + 1, shiftLength - 2);
                    const altBreakTime = timeSlots[altBreakHour];
                    schedule[altBreakTime].staffBreaks[s] = "2ND BREAK";
                    staffStats[s].secondBreakTime = altBreakTime;
                    staffStats[s].breakTime += 1.0;
                }
            } else {
                // NIGHT SHIFT: Single 2-hour break
                // Place break in the middle of the shift, staggered between the two nurses
                const breakStartOffset = index % 2; // Stagger between the 2 nurses
                const breakStartHour = Math.min(4 + breakStartOffset, 5); // Around middle of shift
                
                // Assign first hour of break
                const firstBreakTime = timeSlots[breakStartHour];
                schedule[firstBreakTime].staffBreaks[s] = "NIGHT BREAK";
                staffStats[s].shortBreakTime = firstBreakTime;
                
                // Assign second hour of break (consecutive)
                const secondBreakTime = timeSlots[breakStartHour + 1];
                schedule[secondBreakTime].staffBreaks[s] = "NIGHT BREAK";
                staffStats[s].secondBreakTime = secondBreakTime;
                
                // Total break time is 2 hours
                staffStats[s].breakTime = 2.0;
            }
        });

        // Render the schedule
        renderSchedule(schedule, staff, patients.map(p => p.name), staffStats);
        
        // Save to localStorage
        saveToLocalStorage();

        // After schedule is generated, update debug panel if it's open
        if (document.getElementById('debugPanel').style.display !== 'none') {
            updateDebugPanelData();
        }
    } catch (error) {
        logError("Schedule Generation Error", "Failed to generate schedule", error);
        showError("Failed to generate schedule. Please check your inputs and try again.");
    }
}

        function renderSchedule(schedule, staff, patients, staffStats) {
            // Generate colors for staff
            const staffColors = generateStaffColors(staff);
            
            // Reset work hours in staffStats
            staff.forEach(s => {
                staffStats[s].workHours = 0;
                staffStats[s].breakTime = 0;
            });
            
            // Make sure timeSlots is properly initialized based on current shift
            if (!timeSlots || timeSlots.length === 0) {
                timeSlots = isDayShift ? [...dayShiftSlots] : [...nightShiftSlots];
            }
            
            // Ensure schedule is properly initialized for all time slots
            timeSlots.forEach(time => {
                if (!schedule[time]) {
                    schedule[time] = {
                        patientAssignments: {},
                        staffBreaks: {}
                    };
                }
                
                // Make sure patientAssignments exists
                if (!schedule[time].patientAssignments) {
                    schedule[time].patientAssignments = {};
                }
                
                // Initialize patient assignments if missing
                patients.forEach(patient => {
                    if (!schedule[time].patientAssignments[patient]) {
                        schedule[time].patientAssignments[patient] = [];
                    }
                });
                
                // Make sure staffBreaks exists
                if (!schedule[time].staffBreaks) {
                    schedule[time].staffBreaks = {};
                }
                
                // Initialize staff breaks if missing
                staff.forEach(s => {
                    if (!schedule[time].staffBreaks[s]) {
                        schedule[time].staffBreaks[s] = "";
                    }
                });
            });
            
            // Continue with the rest of the function...
            // Calculate work hours for each staff member
            timeSlots.forEach((time, timeIndex) => {
                staff.forEach(s => {
                    // If security staff on security duty, count as working
                    if (securityStaff.includes(s) && isSecurityRestrictedHour(timeIndex, timeSlots.length)) {
                        staffStats[s].workHours += 1;
                        return; // Skip further checks for this time slot
                    }
                    
                    // Skip if on break
                    if (schedule[time] && schedule[time].staffBreaks && schedule[time].staffBreaks[s]) {
                        // Existing break handling code
                        return;
                    }
                    
                    // Check if staff is working this hour
                    let working = false;
                    for (const patient in schedule[time].patientAssignments) {
                        if (schedule[time].patientAssignments[patient].includes(s)) {
                            working = true;
                            break;
                        }
                    }
                    
                    // Update work hours if working
                    if (working) {
                        staffStats[s].workHours += 1;
                    }
                });
            });
            
            // Setup patient schedule header (time slots horizontally)
            const scheduleHeader = document.getElementById('scheduleHeader');
            let headerHTML = '<tr><th>Patient</th>';
            timeSlots.forEach(time => {
                headerHTML += `<th>${time}</th>`;
            });
            headerHTML += '</tr>';
            scheduleHeader.innerHTML = headerHTML;
            
            // Setup patient schedule body (patient rows)
            const scheduleBody = document.getElementById('scheduleBody');
            scheduleBody.innerHTML = '';
            patients.forEach(patient => {
                const row = document.createElement('tr');
                
                // Add patient name cell
                const patientCell = document.createElement('td');
                patientCell.textContent = patient;
                patientCell.className = 'row-header';
                row.appendChild(patientCell);
                
                // Add cells for each time slot
                timeSlots.forEach(time => {
                    const cell = document.createElement('td');
                    const assignedStaff = schedule[time].patientAssignments[patient];
                    
                    if (assignedStaff.length === 0) {
                        cell.textContent = "UNASSIGNED";
                        cell.style.backgroundColor = "#ffeaa7"; // Yellow for unassigned
                        cell.style.color = "#000000"; // Black text for contrast
                    } else {
                        cell.textContent = assignedStaff.join(", ");
                        
                        // Add a check to ensure assignedStaff[0] exists and is in staffColors
                        if (assignedStaff.length > 0 && staffColors[assignedStaff[0]]) {
                            const { bgColor, textColor } = staffColors[assignedStaff[0]]; // Use the first staff's color
                            cell.style.backgroundColor = bgColor;
                            cell.style.color = textColor; // Set text color for contrast
                        } else {
                            // Fallback colors if no valid staff color is found
                            cell.style.backgroundColor = "#f8f9fa"; // Light gray background
                            cell.style.color = "#000000"; // Black text for contrast
                        }
                    }
                    
                    row.appendChild(cell);
                });
                
                scheduleBody.appendChild(row);
            });
            
            // Setup staff schedule header (same as patient schedule)
            const staffHeader = document.getElementById('staffHeader');
            staffHeader.innerHTML = headerHTML;
            
            // Setup staff schedule body (staff rows)
            const staffBody = document.getElementById('staffBody');
            staffBody.innerHTML = '';
            staff.forEach(s => {
                const row = document.createElement('tr');
                
                // Add staff name cell
                const staffCell = document.createElement('td');
                staffCell.textContent = s;
                staffCell.className = 'row-header';

                // Check if this is security staff
                if (securityStaff.includes(s)) {
                    // Special styling for security staff name cell
                    staffCell.style.backgroundColor = "#ff9800"; // Orange background
                    staffCell.style.color = "#000000"; // Black text for contrast
                    staffCell.style.fontWeight = "bold";
                    staffCell.textContent = s + " (Security)"; // Add explicit label
                } else if (staffColors[s]) {
                    // Regular staff with their assigned color
                    const { bgColor, textColor } = staffColors[s];
                    staffCell.style.backgroundColor = bgColor;
                    staffCell.style.color = textColor;
                } else {
                    // Fallback colors
                    staffCell.style.backgroundColor = "#f8f9fa"; // Light gray background
                    staffCell.style.color = "#000000"; // Black text for contrast
                }

                row.appendChild(staffCell);
                
                // Add cells for each time slot
                timeSlots.forEach((time, timeIndex) => {
                    const cell = document.createElement('td');
                    const breakStatus = schedule[time].staffBreaks[s];
                    
                    // Check if security staff on security duty
                    if (securityStaff.includes(s) && isSecurityRestrictedHour(timeIndex, timeSlots.length)) {
                        cell.textContent = "SECURITY";
                        cell.style.backgroundColor = "#ffccbc";
                        cell.style.color = "#000000";
                        cell.style.fontWeight = "bold";
                    }
                    else if (breakStatus === "30-MIN BREAK") {
                        cell.textContent = "BREAK";
                        cell.className = 'staff-break';
                    } else if (breakStatus === "2ND BREAK") {
                        cell.textContent = "2ND BREAK";
                        cell.className = 'staff-lunch';
                    } else if (breakStatus === "NIGHT BREAK") {
                        cell.textContent = "BREAK";
                        cell.style.backgroundColor = "#673ab7"; // Purple for night break
                        cell.style.color = "#ffffff";
                    } else if (breakStatus && cleaningDuties.includes(breakStatus)) {
                        // This is for cleaning duties
                        cell.textContent = breakStatus;
                        cell.style.backgroundColor = "#9c27b0"; // Purple for cleaning duties
                        cell.style.color = "#ffffff";
                    } else {
                        // Rest of code for normal cell rendering
                        let assigned = false;
                        for (const patient in schedule[time].patientAssignments) {
                            if (schedule[time].patientAssignments[patient].includes(s)) {
                                cell.textContent = patient;
                                
                                // Add safety check for staff colors
                                if (staffColors[s]) {
                                    cell.style.backgroundColor = staffColors[s].bgColor;
                                    cell.style.color = staffColors[s].textColor;
                                } else {
                                    cell.style.backgroundColor = "#f8f9fa"; // Fallback light gray
                                    cell.style.color = "#000000"; // Black text
                                }
                                
                                assigned = true;
                                break;
                            }
                        }
                        
                        if (!assigned) {
                            cell.textContent = "FREE";
                            cell.style.backgroundColor = "#e0f7fa"; // Light blue for free time
                            cell.style.color = "#000000"; // Explicitly set text color to black for better visibility
                        }
                    }
                    
                    row.appendChild(cell);
                });
                
                staffBody.appendChild(row);
            });
            
            // Show statistics
            renderStats(staffStats, staff, patients);
            renderBreakHoursTable(staffStats, staff);
            renderStaffRotationStats(patients, staff);
        }

        function renderStats(staffStats, staff, patients) {
            let statsHtml = '<h2>Health Care Worker (HCW) Work Summary</h2>';
            statsHtml += '<table>';
            
            if (isDayShift) {
                statsHtml += '<tr><th>HCW</th><th>Work Hours</th><th>Break Time</th><th>30-min Break</th><th>1-hour 2nd Break</th></tr>';
            } else {
                statsHtml += '<tr><th>HCW</th><th>Work Hours</th><th>Break Time</th><th>Break Time</th><th>Cleaning Duties</th></tr>';
            }
            
            staff.forEach(s => {
                if (isDayShift) {
                    statsHtml += `<tr>
                        <td>${s}</td>
                        <td>${staffStats[s].workHours} hours</td>
                        <td>${staffStats[s].breakTime} hours</td>
                        <td>${staffStats[s].shortBreakTime}</td>
                        <td>${staffStats[s].secondBreakTime}</td>
                    </tr>`;
                } else {
                    // Display cleaning duties for night shift
                    let cleaningDutiesText = "None";
                    if (staffStats[s].cleaningDuties && staffStats[s].cleaningDuties.length > 0) {
                        cleaningDutiesText = staffStats[s].cleaningDuties
                            .map(item => `${item.duty} (${item.time})`)
                            .join(', ');
                    }
                    
                    statsHtml += `<tr>
                        <td>${s}</td>
                        <td>${staffStats[s].workHours} hours</td>
                        <td>${staffStats[s].breakTime} hours</td>
                        <td>${staffStats[s].shortBreakTime ? staffStats[s].shortBreakTime + " to " + staffStats[s].secondBreakTime : "N/A"}</td>
                        <td>${cleaningDutiesText}</td>
                    </tr>`;
                }
            });
            
            statsHtml += '</table>';
            
            // Add schedule coverage
            statsHtml += '<h2>Schedule Coverage</h2>';
            statsHtml += `<p>Total HCWs: ${staff.length}</p>`;
            statsHtml += `<p>Total Patients: ${patients.length}</p>`;
            
            // Calculate patient-to-HCW ratio
            const ratio = staff.length / patients.length;
            statsHtml += `<p>HCW-to-Patient Ratio: ${ratio.toFixed(2)}:1</p>`;
            
            // Calculate workload balance metrics
            const workHours = staff.map(s => staffStats[s].workHours);
            const maxHours = Math.max(...workHours);
            const minHours = Math.min(...workHours);
            const avgHours = workHours.reduce((sum, hours) => sum + hours, 0) / staff.length;
            const balanceScore = maxHours - minHours; // Lower is better
            
            statsHtml += '<h3>Work Balance Metrics</h3>';
            statsHtml += `<p>Maximum Work Hours: ${maxHours}</p>`;
            statsHtml += `<p>Minimum Work Hours: ${minHours}</p>`;
            statsHtml += `<p>Average Work Hours: ${avgHours.toFixed(1)}</p>`;
            statsHtml += `<p>Balance Score: ${balanceScore} (lower is better)</p>`;
            
            // Add this to the end of the renderStats function
            if (!isDayShift) {
                // Add a cleaning duties summary
                statsHtml += '<h3>Night Shift Cleaning Duties Summary</h3>';
                statsHtml += '<table>';
                statsHtml += '<tr><th>Duty</th><th>Assigned To</th><th>Time</th></tr>';
                
                // Create a map of duties to staff
                const dutyAssignments = {};
                staff.forEach(s => {
                    if (staffStats[s].cleaningDuties) {
                        staffStats[s].cleaningDuties.forEach(item => {
                            dutyAssignments[item.duty] = {
                                staff: s,
                                time: item.time
                            };
                        });
                    }
                });
                
                // List all possible cleaning duties
                cleaningDuties.forEach(duty => {
                    const assignment = dutyAssignments[duty];
                    if (assignment) {
                        statsHtml += `<tr>
                            <td>${duty}</td>
                            <td>${assignment.staff}</td>
                            <td>${assignment.time}</td>
                        </tr>`;
                    } else {
                        statsHtml += `<tr>
                            <td>${duty}</td>
                            <td>Not Assigned</td>
                            <td>N/A</td>
                        </tr>`;
                    }
                });
                
                statsHtml += '</table>';
            }
            
            // Set the HTML for the stats section
            document.getElementById('stats').innerHTML = statsHtml;
        }

        function renderBreakHoursTable(staffStats, staff) {
            const breakHoursTableBody = document.querySelector('#breakHoursTable tbody');
            
            staff.forEach(s => {
                const row = document.createElement('tr');
                
                // Staff name
                const staffCell = document.createElement('td');
                staffCell.textContent = s;
                row.appendChild(staffCell);
                
                // 30-min Break
                const shortBreakCell = document.createElement('td');
                shortBreakCell.textContent = staffStats[s].shortBreakTime || 'N/A';
                row.appendChild(shortBreakCell);
                
                // 2nd Break
                const secondBreakCell = document.createElement('td');
                secondBreakCell.textContent = staffStats[s].secondBreakTime || 'N/A';
                row.appendChild(secondBreakCell);
                
                breakHoursTableBody.appendChild(row);
            });
        }

        function renderStaffRotationStats(patients, staff) {
            // Check if we have patients and staff to render
            if (!patients || !patients.length || !staff || !staff.length) {
                document.getElementById('rotationStats').innerHTML = '<h3>Staff-Patient Rotation Summary</h3><p>No data available.</p>';
                return;
            }

            let rotationHtml = '<h3>Staff-Patient Rotation Summary</h3>';
            rotationHtml += '<table class="rotation-table">';
            
            // Header row with patient names
            rotationHtml += '<tr><th>Staff</th>';
            patients.forEach(patient => {
                const patientName = typeof patient === 'object' ? patient.name : patient;
                rotationHtml += `<th>${patientName}</th>`;
            });
            rotationHtml += '</tr>';
            
            // Rows for each staff member
            staff.forEach(s => {
                rotationHtml += `<tr><td>${s}</td>`;
                
                patients.forEach(patient => {
                    const patientName = typeof patient === 'object' ? patient.name : patient;
                    // Check if staffPatientHistory exists and has data for this staff/patient
                    const count = (staffPatientHistory && 
                                  staffPatientHistory[s] && 
                                  staffPatientHistory[s][patientName]) 
                        ? staffPatientHistory[s][patientName] 
                        : 0;
                    
                    // Color scale: darker green means more time spent with this patient
                    const intensity = Math.min(count * 20, 255);
                    const bgColor = `rgba(76, 175, 80, ${intensity/255})`;
                    
                    rotationHtml += `<td style="background-color: ${bgColor};">${count}</td>`;
                });
                
                rotationHtml += '</tr>';
            });
            
            rotationHtml += '</table>';
            
            // Add rotation visualization to stats
            document.getElementById('rotationStats').innerHTML = rotationHtml;
        }

        // Add this new function to simplify updating the legend
function updateLegend() {
    const legendDiv = document.querySelector('.legend');
    if (isDayShift) {
        legendDiv.innerHTML = `
            <div class="legend-item">
                <div class="legend-color legend-break"></div>
                <div>30-min Break</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-lunch"></div>
                <div>1-hour 2nd Break</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-unassigned"></div>
                <div>Unassigned</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-security"></div>
                <div>Security Duty</div>
            </div>
        `;
    } else {
        legendDiv.innerHTML = `
            <div class="legend-item">
                <div class="legend-color legend-night-break"></div>
                <div>2-hour Break</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-cleaning-duty"></div>
                <div>Cleaning Duty</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-unassigned"></div>
                <div>Unassigned</div>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-security"></div>
                <div>Security Duty</div>
            </div>
        `;
    }
    
    // Update break hours table header
    const breakHoursTableHead = document.querySelector('#breakHoursTable thead');
    if (isDayShift) {
        breakHoursTableHead.innerHTML = `
        <tr>
            <th>Staff</th>
            <th>30-min Break</th>
            <th>1-hour 2nd Break</th>
        </tr>`;
    } else {
        breakHoursTableHead.innerHTML = `
        <tr>
            <th>Staff</th>
            <th>Break Start</th>
            <th>Break End</th>
        </tr>`;
    }
}

        // Add this to your window.onload function
document.getElementById('toggleDebugBtn').addEventListener('click', function() {
    const debugPanel = document.getElementById('debugPanel');
    if (debugPanel.style.display === 'none') {
        debugPanel.style.display = 'block';
        
        // Add current state information
        logError("Info", `Current shift: ${isDayShift ? 'Day Shift' : 'Night Shift'}`);
        logError("Info", `Dark mode: ${document.body.classList.contains('dark-mode') ? 'Enabled' : 'Disabled'}`);
        logError("Info", `Staff count: ${document.querySelectorAll('.staff-container').length}`);
        logError("Info", `Patient count: ${document.querySelectorAll('.patient-container').length}`);
    } else {
        debugPanel.style.display = 'none';
    }
});

document.getElementById('clearDebugBtn').addEventListener('click', function() {
    document.getElementById('debugOutput').innerHTML = '';
});

// Add a close button to the debug panel header
const debugPanelHeader = document.querySelector('#debugPanel h3');
const closeDebugPanelBtn = document.createElement('span');
closeDebugPanelBtn.innerHTML = '✖';
closeDebugPanelBtn.style.position = 'absolute';
closeDebugPanelBtn.style.right = '40px';
closeDebugPanelBtn.style.top = '10px';
closeDebugPanelBtn.style.cursor = 'pointer';
closeDebugPanelBtn.style.fontSize = '16px';
closeDebugPanelBtn.style.fontWeight = 'bold';
closeDebugPanelBtn.style.color = '#ffffff'; // Ensure white text color for visibility
closeDebugPanelBtn.title = 'Close Debug Console';

// Add a hover effect for better UX
closeDebugPanelBtn.addEventListener('mouseover', function() {
    this.style.color = '#ff5555'; // Red on hover
});
closeDebugPanelBtn.addEventListener('mouseout', function() {
    this.style.color = '#ffffff'; // Back to white
});

// Insert the close button after the heading
debugPanelHeader.after(closeDebugPanelBtn);

// Capture global errors
window.onerror = function(message, source, lineno, colno, error) {
    logError("Global Error", `${message} at line ${lineno}:${colno}`, error);
    return false; // Let the default handler run as well
};

// Capture promise rejections
window.onunhandledrejection = function(event) {
    logError("Unhandled Promise Rejection", event.reason.message || "Unknown promise error", event.reason);
};

        // Enhance the logError function to show more detailed information in the debug panel
function logError(errorType, message, errorObject = null) {
    console.error(`[${errorType}] ${message}`);
    if (errorObject) {
        console.error(errorObject);
    }
    
    // Format timestamp
    const now = new Date();
    const timestamp = now.toLocaleTimeString() + '.' + now.getMilliseconds().toString().padStart(3, '0');
    
    // Also log to a debug element if present
    const debugElement = document.getElementById('debugOutput');
    if (debugElement) {
        const errorEntry = document.createElement('div');
        errorEntry.className = 'error-entry';
        errorEntry.style.borderBottom = '1px solid #555';
        errorEntry.style.paddingBottom = '8px';
        errorEntry.style.marginBottom = '8px';
        
        // Add timestamp and error type with color coding
        let errorColor = '#ff5555'; // Default red
        if (errorType === 'Info') errorColor = '#55aaff';
        if (errorType === 'Warning') errorColor = '#ffaa55';
        
        errorEntry.innerHTML = `<div style="color: #aaa; font-size: 11px;">[${timestamp}]</div>
                               <div style="color: ${errorColor}; font-weight: bold;">${errorType}</div>
                               <div>${message}</div>`;
        
        // Add error object details if present
        if (errorObject && errorObject.stack) {
            const stackDiv = document.createElement('div');
            stackDiv.style.marginTop = '5px';
            stackDiv.style.color = '#aaa';
            stackDiv.style.fontSize = '11px';
            stackDiv.style.fontFamily = 'monospace';
            stackDiv.style.whiteSpace = 'pre-wrap';
            stackDiv.textContent = errorObject.stack.split('\n').slice(0, 3).join('\n'); // Show first 3 lines
            errorEntry.appendChild(stackDiv);
        }
        
        // Add to the beginning so newest errors are at the top
        debugElement.insertBefore(errorEntry, debugElement.firstChild);
    }
}

// Add this to the window.onload to make the debug panel more informative from the start
logError("Info", "Debug console initialized. Errors and warnings will appear here.");

        // Enhance the saveToLocalStorage function to explicitly save all UI state
function saveToLocalStorage() {
    try {
        // Get all current values
        const staffInputs = Array.from(document.querySelectorAll('.staff-name')).map(input => input.value.trim());
        const patientInputs = Array.from(document.querySelectorAll('.patient-container')).map(container => {
            return {
                name: container.querySelector('.patient-name').value.trim(),
                staffCount: parseInt(container.querySelector('.staff-count').value)
            };
        });
        
        const securityStaffValues = Array.from(document.querySelectorAll('.security-name')).map(input => input.value.trim());
        const nurseInCharge1 = document.getElementById('nurseInChargeInput')?.value.trim() || '';
        const nurseInCharge2 = document.getElementById('nurseInCharge2Input')?.value.trim() || '';
        
        // Get UI state explicitly
        const isDark = document.body.classList.contains('dark-mode');
        
        const data = {
            staff: staffInputs,
            nurses: [nurseInCharge1, nurseInCharge2].filter(Boolean),
            nurseInCharge1,
            nurseInCharge2,
            patients: patientInputs,
            securityStaff: securityStaffValues,
            schedule,
            isDayShift,
            isDarkMode: isDark,
            staffPatientHistory: staffPatientHistory || {}
        };
        
        localStorage.setItem('patientCareData', JSON.stringify(data));

        // After saving, update debug panel if it's open
        if (document.getElementById('debugPanel').style.display !== 'none') {
            updateDebugPanelData();
        }
        
        return true;
    } catch (error) {
        logError("Storage Error", "Failed to save data to localStorage", error);
        showError("Failed to save your changes. Your browser storage might be full or restricted.");
        return false;
    }
}

        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('patientCareData');
                if (!savedData) {
                    console.warn("No data found in localStorage.");
                    // Add default data
                    addStaffInput();
                    addPatientInput();
                    return false;
                }
                
                const parsedData = JSON.parse(savedData);
                
                // Load shift type
                isDayShift = parsedData.isDayShift !== undefined ? parsedData.isDayShift : true;
                timeSlots = isDayShift ? [...dayShiftSlots] : [...nightShiftSlots];
                
                // Update UI for shift type
                document.getElementById('siteTitle').textContent = isDayShift ? "Day Shift Allocation" : "Night Shift Allocation";
                document.getElementById('toggleShiftBtn').textContent = isDayShift ? "Switch to Night Shift" : "Switch to Day Shift";
                
                // Load dark mode setting
                if (parsedData.isDarkMode) {
                    document.body.classList.add('dark-mode');
                    document.getElementById('toggleModeBtn').textContent = '☀️';
                } else {
                    document.body.classList.remove('dark-mode');
                    document.getElementById('toggleModeBtn').textContent = '🌙';
                }
                
                // Load nurse in charge values
                if (document.getElementById('nurseInChargeInput')) {
                    document.getElementById('nurseInChargeInput').value = parsedData.nurseInCharge1 || '';
                }
                if (document.getElementById('nurseInCharge2Input')) {
                    document.getElementById('nurseInCharge2Input').value = parsedData.nurseInCharge2 || '';
                }
                
                // Load staff, patients, and security staff
                loadStaffFromData(parsedData.staff || []);
                loadPatientsFromData(parsedData.patients || []);
                loadSecurityStaffFromData(parsedData.securityStaff || []);
                
                // Load rotation history
                staffPatientHistory = parsedData.staffPatientHistory || {};
                
                // Load schedule
                if (parsedData.schedule && Object.keys(parsedData.schedule).length > 0) {
                    schedule = parsedData.schedule;
                    
                    // Render the schedule if it exists
                    const staff = [
                        ...(parsedData.staff || []), 
                        ...(parsedData.securityStaff || []),
                        parsedData.nurseInCharge1,
                        parsedData.nurseInCharge2
                    ].filter(Boolean);
                    
                    const patients = (parsedData.patients || []).map(p => p.name).filter(Boolean);
                    
                    // Create staffStats for rendering
                    const staffStats = {};
                    staff.forEach(s => {
                        staffStats[s] = {
                            workHours: 0,
                            breakTime: 0,
                            shortBreakTime: "",
                            secondBreakTime: ""
                        };
                    });
                    
                    // Render the schedule
                    renderSchedule(schedule, staff, patients, staffStats);
                }
                
                console.log("Data loaded successfully from localStorage");
                return true;
            } catch (error) {
                logError("Load Error", "Failed to load data from localStorage", error);
                showError("Failed to load your saved data. Using default settings instead.");
                return false;
            }
        }

        // Helper functions for loadFromLocalStorage
        function loadStaffFromData(staffData) {
            const staffInputs = document.getElementById('staffInputs');
            staffInputs.innerHTML = '';
            
            staffData.forEach(name => {
                const staffContainer = document.createElement('div');
                staffContainer.className = 'staff-container';
                
                const newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.value = name;
                newInput.className = 'staff-name';
                newInput.addEventListener('input', debounce(saveToLocalStorage, 300));
                
                staffContainer.appendChild(newInput);
                staffInputs.appendChild(staffContainer);
            });
            
            // Add at least one staff input if none were loaded
            if (staffData.length === 0) {
                addStaffInput();
            }
        }

        function loadPatientsFromData(patientsData) {
            const patientInputs = document.getElementById('patientInputs');
            patientInputs.innerHTML = '';
            
            patientsData.forEach(({ name, staffCount }) => {
                const patientContainer = document.createElement('div');
                patientContainer.className = 'patient-container';
                
                const inputWrapper = document.createElement('div');
                inputWrapper.style.display = 'flex';
                inputWrapper.style.alignItems = 'center';
                inputWrapper.style.gap = '10px';
                
                const newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.value = name;
                newInput.className = 'patient-name';
                newInput.addEventListener('input', debounce(saveToLocalStorage, 300));
                
                const staffCountSelect = document.createElement('select');
                staffCountSelect.className = 'staff-count';
                staffCountSelect.addEventListener('change', debounce(saveToLocalStorage, 300));
                
                const option1 = document.createElement('option');
                option1.value = 1;
                option1.textContent = '1:1';
                const option2 = document.createElement('option');
                option2.value = 2;
                option2.textContent = '2:1';
                const option3 = document.createElement('option');
                option3.value = 3;
                option3.textContent = '3:1';
                
                staffCountSelect.appendChild(option1);
                staffCountSelect.appendChild(option2);
                staffCountSelect.appendChild(option3);
                staffCountSelect.value = staffCount || 1;
                
                inputWrapper.appendChild(newInput);
                inputWrapper.appendChild(staffCountSelect);
                patientContainer.appendChild(inputWrapper);
                patientInputs.appendChild(patientContainer);
            });
            
            // Add at least one patient input if none were loaded
            if (patientsData.length === 0) {
                addPatientInput();
            }
        }

        function loadSecurityStaffFromData(securityStaffData) {
            const securityStaffInputs = document.getElementById('securityStaffInputs');
            securityStaffInputs.innerHTML = '';
            
            // Reset the global array
            securityStaff = [];
            
            securityStaffData.forEach(name => {
                if (!securityStaff.includes(name)) {
                    securityStaff.push(name);
                }
                
                const securityContainer = document.createElement('div');
                securityContainer.className = 'security-container';
                
                const newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.value = name;
                newInput.className = 'security-name';
                newInput.addEventListener('input', debounce(saveToLocalStorage, 300));
                
                securityContainer.appendChild(newInput);
                securityStaffInputs.appendChild(securityContainer);
            });
        }

        function clearAllData() {
            // Clear all input containers
            document.getElementById('staffInputs').innerHTML = '';
            document.getElementById('patientInputs').innerHTML = '';
            document.getElementById('securityStaffInputs').innerHTML = '';
            document.getElementById('nurseInChargeInput').value = '';
            document.getElementById('nurseInCharge2Input').value = '';

            // Clear all display areas
            document.getElementById('scheduleHeader').innerHTML = '';
            document.getElementById('scheduleBody').innerHTML = '';
            document.getElementById('staffHeader').innerHTML = '';
            document.getElementById('staffBody').innerHTML = '';
            document.getElementById('breakHoursTable').querySelector('tbody').innerHTML = '';
            document.getElementById('stats').innerHTML = '';
            
            // Reset variables
            schedule = {};
            isDayShift = true;
            timeSlots = [...dayShiftSlots];
        }

        // Function to add staff input
function addStaffInput() {
    const staffInputs = document.getElementById('staffInputs');
    
    const staffContainer = document.createElement('div');
    staffContainer.className = 'staff-container';
    
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.placeholder = 'Enter HCW Name';
    newInput.className = 'staff-name';
    
    staffContainer.appendChild(newInput);
    staffInputs.appendChild(staffContainer);
    
    // Add event listener to the new input
    newInput.addEventListener('input', debounce(saveToLocalStorage, 300));
    
    saveToLocalStorage();
}

// Function to add patient input
function addPatientInput() {
    const patientInputs = document.getElementById('patientInputs');
    
    const patientContainer = document.createElement('div');
    patientContainer.className = 'patient-container';
    
    const inputWrapper = document.createElement('div');
    inputWrapper.style.display = 'flex';
    inputWrapper.style.alignItems = 'center';
    inputWrapper.style.gap = '10px';
    
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.placeholder = 'Enter Patient Name';
    newInput.className = 'patient-name';
    
    const staffCountSelect = document.createElement('select');
    staffCountSelect.className = 'staff-count';
    
    const option1 = document.createElement('option');
    option1.value = 1;
    option1.textContent = '1:1';
    const option2 = document.createElement('option');
    option2.value = 2;
    option2.textContent = '2:1';
    const option3 = document.createElement('option');
    option3.value = 3;
    option3.textContent = '3:1';
    
    staffCountSelect.appendChild(option1);
    staffCountSelect.appendChild(option2);
    staffCountSelect.appendChild(option3);
    staffCountSelect.value = 1; // Default to 1:1
    
    inputWrapper.appendChild(newInput);
    inputWrapper.appendChild(staffCountSelect);
    patientContainer.appendChild(inputWrapper);
    patientInputs.appendChild(patientContainer);
    
    // Add event listeners to the new elements
    newInput.addEventListener('input', debounce(saveToLocalStorage, 300));
    staffCountSelect.addEventListener('change', debounce(saveToLocalStorage, 300));
    
    saveToLocalStorage();
}

// Function to add security staff input
function addSecurityStaffInput() {
    const securityStaffInputs = document.getElementById('securityStaffInputs');
    
    // Check if we've reached the 1 security staff limit
    if (securityStaffInputs.children.length >= 1) {
        showError("Maximum of 1 security staff allowed");
        return;
    }
    
    const securityContainer = document.createElement('div');
    securityContainer.className = 'security-container';
    
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.placeholder = 'Enter Security Staff Name';
    newInput.className = 'security-name';
    
    securityContainer.appendChild(newInput);
    securityStaffInputs.appendChild(securityContainer);
    
    // Add event listener to the new input
    newInput.addEventListener('input', debounce(saveToLocalStorage, 300));
    
    saveToLocalStorage();
}

// Function to check if time is restricted for security
function isSecurityRestrictedHour(timeIndex, totalHours) {
    // First 2 hours or last 2 hours
    return timeIndex < 2 || timeIndex >= totalHours - 2;
}

// Create a function to update the debug panel with live data
function updateDebugPanelData() {
    // Clear existing info messages (keep errors)
    const debugOutput = document.getElementById('debugOutput');
    const infoMessages = debugOutput.querySelectorAll('.error-entry div[style*="color: #55aaff"]');
    infoMessages.forEach(msg => {
        const parent = msg.closest('.error-entry');
        if (parent) parent.remove();
    });
    
    // Add current application state
    logError("Info", `Current shift: ${isDayShift ? 'Day Shift' : 'Night Shift'}`);
    logError("Info", `Dark mode: ${document.body.classList.contains('dark-mode') ? 'Enabled' : 'Disabled'}`);
    
    // Count staff and patients
    const staffCount = document.querySelectorAll('.staff-container').length;
    const patientCount = document.querySelectorAll('.patient-container').length;
    const securityCount = document.querySelectorAll('.security-container').length;
    logError("Info", `Staff count: ${staffCount} HCW, ${securityCount} Security`);
    logError("Info", `Patient count: ${patientCount}`);
    
    // Schedule information
    const scheduleExists = Object.keys(schedule).length > 0;
    logError("Info", `Schedule: ${scheduleExists ? 'Generated' : 'Not generated'}`);
    
    // Show local storage usage
    const storageUsed = new TextEncoder().encode(
        JSON.stringify(localStorage.getItem('patientCareData'))
    ).length;
    logError("Info", `Local storage used: ${(storageUsed / 1024).toFixed(2)} KB`);
    
    // Show browser and screen info
    logError("Info", `Browser: ${navigator.userAgent.match(/(?:Chrome|Firefox|Safari|Edge|MSIE)\/[\d.]+/)[0]}`);
    logError("Info", `Screen: ${window.innerWidth}x${window.innerHeight}px`);
    
    // Time info
    const now = new Date();
    logError("Info", `Current time: ${now.toLocaleTimeString()} (${isDayShift ? 'Day hours' : 'Night hours'})`);
}

// Update the toggleDebugBtn click handler to refresh data
document.getElementById('toggleDebugBtn').addEventListener('click', function() {
    const debugPanel = document.getElementById('debugPanel');
    if (debugPanel.style.display === 'none') {
        debugPanel.style.display = 'block';
        // Update with fresh data each time the panel is opened
        updateDebugPanelData();
    } else {
        debugPanel.style.display = 'none';
    }
});

// Add auto-refresh to debug panel
let debugRefreshInterval;
function startDebugAutoRefresh() {
    // Clear any existing interval
    if (debugRefreshInterval) clearInterval(debugRefreshInterval);
    
    // Set up auto-refresh every 5 seconds when panel is visible
    debugRefreshInterval = setInterval(() => {
        if (document.getElementById('debugPanel').style.display !== 'none') {
            updateDebugPanelData();
        }
    }, 5000); // Update every 5 seconds
}

// Add a refresh button to the debug panel
const refreshDebugBtn = document.createElement('button');
refreshDebugBtn.innerHTML = '🔄';
refreshDebugBtn.style.position = 'absolute';
refreshDebugBtn.style.top = '10px';
refreshDebugBtn.style.right = '70px';
refreshDebugBtn.style.backgroundColor = '#007bff';
refreshDebugBtn.style.color = 'white';
refreshDebugBtn.style.border = 'none';
refreshDebugBtn.style.borderRadius = '4px';
refreshDebugBtn.style.padding = '5px';
refreshDebugBtn.title = 'Refresh Debug Data';
refreshDebugBtn.addEventListener('click', updateDebugPanelData);
document.getElementById('debugPanel').appendChild(refreshDebugBtn);

// Start auto-refresh when page loads
window.onload = function() {
    // Set moon emoji for dark mode button
    document.getElementById('toggleModeBtn').innerHTML = '🌙';
    
    try {
        // Load data from localStorage
        loadFromLocalStorage();
        
        // Make sure dark mode is correctly applied based on saved preference
        const savedData = localStorage.getItem('patientCareData');
        if (savedData) {
            const parsedData = JSON.parse(savedData);
            if (parsedData.isDarkMode) {
                document.body.classList.add('dark-mode');
                document.getElementById('toggleModeBtn').textContent = '☀️';
            } else {
                document.body.classList.remove('dark-mode');
                document.getElementById('toggleModeBtn').textContent = '🌙';
            }
        }
        
        // Rest of your onload code...
    } catch (error) {
        logError("Initialization Error", "Failed to initialize application", error);
    }

    // Initialize inputs if none exist
    if (document.getElementById('staffInputs').children.length === 0) {
        addStaffInput();
    }
    if (document.getElementById('patientInputs').children.length === 0) {
        addPatientInput();
    }
    if (document.getElementById('securityStaffInputs').children.length === 0) {
        addSecurityStaffInput();
    }

    // Initialize legend
    updateLegend();

    // Start debug panel auto-refresh
    startDebugAutoRefresh();
};

document.getElementById('resetRotationBtn').addEventListener('click', () => {
    // Get current staff and patients from inputs
    const currentStaff = Array.from(document.querySelectorAll('.staff-name')).map(input => input.value.trim());
    
    // Get security staff too
    const currentSecurityStaff = Array.from(document.querySelectorAll('.security-name')).map(input => input.value.trim());
    
    // Combine regular and security staff
    const allStaff = [...currentStaff, ...currentSecurityStaff];
    
    // Get current patients
    const currentPatients = Array.from(document.querySelectorAll('.patient-container')).map(container => {
        return {
            name: container.querySelector('.patient-name').value.trim(),
            staffCount: parseInt(container.querySelector('.staff-count').value)
        };
    });
    
    // Reset staffPatientHistory
    staffPatientHistory = {};
    
    // Initialize for current staff and patients
    allStaff.forEach(s => {
        if (s) { // Only process non-empty staff names
            staffPatientHistory[s] = {};
            currentPatients.forEach(patient => {
                if (patient.name) { // Only process non-empty patient names
                    staffPatientHistory[s][patient.name] = 0;
                }
            });
        }
    });
    
    // Save to localStorage
    saveToLocalStorage();
    
    // Show confirmation
    const confirmationDiv = document.createElement('div');
    confirmationDiv.className = 'error-message'; // Using the existing error-message class
    confirmationDiv.style.backgroundColor = '#4CAF50'; // Green for success
    confirmationDiv.textContent = "Staff rotation history has been reset.";
    document.body.appendChild(confirmationDiv);
    setTimeout(() => confirmationDiv.remove(), 3000);
    
    // Regenerate schedule if exists
    if (Object.keys(schedule).length > 0) {
        generateSchedule();
    } else {
        // If no schedule, just update the rotation stats display
        renderStaffRotationStats(
            currentPatients.map(p => p.name), 
            allStaff.filter(s => s) // Filter out empty strings
        );
    }
});

        // Add these event listeners to your window.onload function
document.getElementById('generateBtn').addEventListener('click', generateSchedule);

document.getElementById('resetBtn').addEventListener('click', function() {
    clearAllData();
    localStorage.removeItem('patientCareData');
    addStaffInput();
    addPatientInput();
    addSecurityStaffInput();
});

document.getElementById('addStaffBtn').addEventListener('click', addStaffInput);
document.getElementById('removeStaffBtn').addEventListener('click', function() {
    const staffInputs = document.getElementById('staffInputs');
    if (staffInputs.lastChild) {
        staffInputs.removeChild(staffInputs.lastChild);
        saveToLocalStorage();
    }
});

document.getElementById('addPatientBtn').addEventListener('click', addPatientInput);
document.getElementById('removePatientBtn').addEventListener('click', function() {
    const patientInputs = document.getElementById('patientInputs');
    if (patientInputs.lastChild) {
        patientInputs.removeChild(patientInputs.lastChild);
        saveToLocalStorage();
    }
});

document.getElementById('addSecurityStaffBtn').addEventListener('click', addSecurityStaffInput);
document.getElementById('removeSecurityStaffBtn').addEventListener('click', function() {
    const securityStaffInputs = document.getElementById('securityStaffInputs');
    if (securityStaffInputs.lastChild) {
        securityStaffInputs.removeChild(securityStaffInputs.lastChild);
        saveToLocalStorage();
    }
});

document.getElementById('toggleShiftBtn').addEventListener('click', function() {
    isDayShift = !isDayShift;
    timeSlots = isDayShift ? [...dayShiftSlots] : [...nightShiftSlots];
    document.getElementById('siteTitle').textContent = isDayShift ? "Day Shift Allocation" : "Night Shift Allocation";
    this.textContent = isDayShift ? "Switch to Night Shift" : "Switch to Day Shift";
    
    // Update legend based on shift
    updateLegend();
    saveToLocalStorage();
    
    // If a schedule exists, regenerate it with the new shift type
    if (Object.keys(schedule).length > 0) {
        generateSchedule();
    }
});

document.getElementById('toggleModeBtn').addEventListener('click', function() {
    document.body.classList.toggle('dark-mode');
    this.textContent = document.body.classList.contains('dark-mode') ? '☀️' : '🌙';
    saveToLocalStorage();
});

document.getElementById('debugFillBtn').addEventListener('click', function() {
    // Mock data
    const staffNames = ['John Smith', 'Maria Rodriguez', 'Robert Johnson', 'Sarah Brown', 'David Lee'];
    const patientNames = ['Patient A', 'Patient B', 'Patient C', 'Patient D'];
    const securityNames = ['Security Officer Jones'];
    const nurseNames = ['Charge Nurse Wilson', 'Charge Nurse Thompson'];
    
    // Fill nurse in charge inputs
    document.getElementById('nurseInChargeInput').value = nurseNames[0];
    document.getElementById('nurseInCharge2Input').value = nurseNames[1];
    
    // Fill existing staff inputs without changing structure
    const staffInputs = document.querySelectorAll('.staff-container .staff-name');
    staffInputs.forEach((input, index) => {
        input.value = index < staffNames.length ? staffNames[index] : `Staff ${index + 1}`;
    });
    
    // Fill existing security staff inputs without changing structure
    const securityStaffInputs = document.querySelectorAll('.security-container .security-name');
    securityStaffInputs.forEach((input, index) => {
        input.value = index < securityNames.length ? securityNames[index] : `Security ${index + 1}`;
    });
    
    // Fill existing patient inputs without changing structure
    const patientContainers = document.querySelectorAll('.patient-container');
    patientContainers.forEach((container, index) => {
        const nameInput = container.querySelector('.patient-name');
        const staffCountSelect = container.querySelector('.staff-count');
        
        nameInput.value = index < patientNames.length ? patientNames[index] : `Patient ${index + 1}`;
        staffCountSelect.value = (index % 3) + 1; // Cycle through 1, 2, 3
    });
    
    // Show confirmation message
    const confirmationDiv = document.createElement('div');
    confirmationDiv.className = 'error-message';
    confirmationDiv.style.backgroundColor = '#4CAF50'; // Green for success
    confirmationDiv.textContent = "Debug data filled successfully!";
    document.body.appendChild(confirmationDiv);
    setTimeout(() => confirmationDiv.remove(), 3000);
    
    // Save to localStorage
    saveToLocalStorage();
});

// Add event listener to document to close debug panel when clicking outside
document.addEventListener('click', function(event) {
    const debugPanel = document.getElementById('debugPanel');
    const toggleButton = document.getElementById('toggleDebugBtn');
    
    // If debug panel is visible
    if (debugPanel.style.display !== 'none') {
        // Check if click was outside debug panel and not on the toggle button
        if (!debugPanel.contains(event.target) && event.target !== toggleButton) {
            debugPanel.style.display = 'none';
        }
    }
});

// Prevent clicks inside the debug panel from bubbling to document
document.getElementById('debugPanel').addEventListener('click', function(event) {
    event.stopPropagation();
});
    </script>
</body>
</html>